UINL (User Interface object-Notation Language)				
v1.2.20250212				
-	-	-	-	-
-	-	-	-	-
Sample Interaction				
### Message Type	### Message Content	### Shorthand Equivalent	### Description	### ---
*** UI->APP ***	{"t":0}		user-agent announces that it has loaded, and requests the initial display; "t":0 indicates that UI clock time is at 0ms	
*** APP->UI ***	{"value":["Hello World!",{"Class":"btn","id":"click me"}]}	{"v":["Hello World!",{"c":"btn","id":"click me"}]}	text "Hello World!" and button "click me" are added to user display	
*** UI->APP ***	{"t":3450,"u":"click me","v":true}		user clicks the button "click me" (3.45s after the UI loaded)	
*** APP->UI ***	{"value":["Goodbye."],"!state":0}		display is cleared, text "Goodbye." is added to the display; "!state":0 indicates that app is closing	
-	-	-	-	-
-	-	-	-	-
UINL Spec & Protocol				
### Message Type	### Grammar	### ---	### Description	### ---
*** UI->APP ***	{(<<uiInfo>>,)*"t":0(,<<uiInfo>>)*}		handshake; this is the first message sent from user-agent to app software once user-agent software is loaded and ready; no other UI->APP or APP->UI messages should precede this message; detailed <<uiInfo>> is strictly voluntary, though highly encouraged (especially "userAgent" and "time" <<uiInfo>>)	
*** UI->APP ***	{<<userProp>>(,<<userProp>>)*}		user-side action/event (e.g. button-click, textbox edit)	
*** APP->UI ***	{(<<uiDirective>>(,<<uiDirective>>)*)?}		app-driven updates to user display; by default UINL protocol is synchronous, requiring an APP->UI message in response to every UI->APP message; when there are no <<uiDirective>>'s (i.e., APP->UI message is {}) that signifies there are no display updates; see <<uiDirective>> "!async" for description of asynchronous mode and how it's enabled	
-	-	-	-	-
### Label Name	### Grammar	### Shorthand	### Description	### Example
<<uiInfo>>	"userAgent":<<text>>		information about UI software (i.e., user-agent name, version)	
<<uiInfo>>	"wh":[<<number>>,<<number>>]		available width/height of application window (in pixels)	
<<uiInfo>>	"ip":<<text>>		user-agent ip address	
<<uiInfo>>	"url":<<text>>		url (if any) employed by UI to connect to the app	
<<uiInfo>>	"time":<<text>>		full user local time, including milliseconds and timezone offset, in ISO8601 format (e.g. "2020-04-27T11:26:43.967-04:00")	
<<uiInfo>>	"platform":<<text>>		information about where UI software is running (i.e., OS, framework)	
<<uiInfo>>	"system":<<settings>>		any user-system information available (e.g., memory available, type of GPU, type of CPU)	
<<uiInfo>>	"screen":<<settings>>		user screen information (e.g. {"availWidth":1168,"availHeight":692,"width":1229,"height":692,"colorDepth":24,"pixelDepth":24,"availLeft":0,"availTop":0,"orientation":{"angle":0,"type":"landscape-primary"}}); at a minimum, if this information is available, returned <<settings>> should include "width":<<number>> and "height":<<number>>	
<<userProp>>	"error":<<text>>		error message to be dumped into app-side error stream	Ex: UI->APP message {"!error":"there is a problem","t":<<ums>>} should write "there is a problem" into app-side error stream
<<userProp>>	"s":<<text>>		session state identifier string; if session state identification is requested by the application via the "S" <<Command>>, this <<userProp>> must be present in all UI->APP messages	Ex: APP->UI message {"S":"bb27458c-7b97-11eb-9439-0242ac130002","v":[{"id":"Press Me","v":false}]} sets session id to bb27458c-7b97-11eb-9439-0242ac130002 and adds a button "Press Me" to display -- when user presses this button, the ensuing UI->APP message will be {"s":"bb27458c-7b97-11eb-9439-0242ac130002","t":<<ums>>,"u":"Press Me","v":true}
<<userProp>>	"t":<<ums>>		timestamp indicating when user input occurred; this <<userProp>> is present in every UI->APP message; <<uint>> must be 0 for handshake and greater than 0 for all other messages	Ex: UI->APP message {"u":"button 1","v":true,"t":7582} signifies that "button 1" was clicked by the user 7.582s from the time that the initial handshake message was sent
<<userProp>>	"u":<<id>>|<<idPath>>		unique id or path for item being toggled/changed by user; this <<userProp>> is present in every UI->APP message, except when when message does not apply to any specific item, but rather to the display as a whole (e.g. {"error":"some error","t":<<ums>>}); <<id>> must be send instead of <<idPath>> whenever <<id>> is unique within display; <<idPath>> must be sent instead of <<id>> whenever <<id>> does not uniquely identify the item within the display	Ex: UI->APP message {"u":"button 1","v":true,"t":<<ums>>} signifies that "button 1" was clicked by the user; Ex: UI->APP message {"u":["buttons",0],"v":true,"t":<<ums>>} signifies that the first button in the "buttons" container was clicked by the user
<<userProp>>	"v":<<value>>		value indicating user-input	Ex: UI->APP message {"u":"button 1","v":true,"t":<<ums>>} signifies that "button 1" was clicked by the user
<<userProp>>	"requirable":{(<<required>>(,<<required>>)*)?}		inform app software which options and option-values are available (i.e., can be required) in user-agent software; this is sent as a response to <<uiDirective>> "!!require":{}	
<<uiDirective>>	"!!require":{}	"require":{}	request the full list of options and option-values that are available (i.e., can be required) in user-agent software; APP->UI message {"!!require":{}} will trigger a corresponding response UI->APP message containing <<userProp>> "requirable":{(<<required>>(,<<required>>)*)?}	
<<uiDirective>>	"!!require":{<<required>>(,<<required>>)*}	"require":{<<required>>(,<<required>>)*}	specify which options and option-values are required for correctly interpreting essential application requests; if any of the <<required>> features need to be imported/loaded, user-agent software should import and load these features upon receiving this <<uiDirective>>; if any of the <<required>> features are not implemented yet in user-agent software, the suggested behavior is to disconnect from the app after a polite {"t":<<ums>>,"error":"<<required>> is not implemented. Disconnecting."}	
<<uiDirective>>	"!state":<<uint>>	"S":<<uint>>	Session closing; "S":<<uint>> indicates that app-software is closing and no more UI->APP messages will be received; APP->UI message {"S":<<uint>>,"v":null} indicates that session is over and the app window should be closed (though the ability to close app window is not guaranteed); state "S":0 indicates that app software closed normally with no errors, and "S":1 or any other <<uint>> indicates that app software closed abnormally due to some error, where the <<uint>> is the error code (0 as normal termination and non-zero integer as abnormal termination are convention exit codes in most programming languages; e.g., C/C#: return 0, Swift: exit(0), Kotlin: exitProcess(0), Java: System.exit(0))	
<<uiDirective>>	"!state":<<text>>	"S":<<text>>	Session state or session id setting; <<text>> is the session status or identifier that must be present as part of "s" <<userProp>> in all subsequent UI->APP messages	Ex: APP->UI message {"S":"bb27458c-7b97-11eb-9439-0242ac130002","v":[{"id":"Press Me","v":false}]} sets session id to "bb27458c-7b97-11eb-9439-0242ac130002" and adds a button "Press Me" to display, and every time the user presses this button, the ensuing UI->APP message will be {"s":"bb27458c-7b97-11eb-9439-0242ac130002","t":<<ums>>,"u":"Press Me","v":true} until there is another APP->UI message with <<uiDirective>> "S" so as to change or clear session state (or until the button is removed or disabled)
<<uiDirective>>	"!state":null	"S":null	clear session state	
<<uiDirective>>	<<itemProp>>		options for root container; root container is a special container that has no id, no class, and cannot be deleted; only allows its "v" property to be <<container>> (not <<value>>)	
<<itemProp>>	<<property>>		set item property	
<<itemProp>>	<<Command>>		Commands alter how properties are updated (but are not themselves lasting item properties)	
<<property>>	"Class":<<itemClass>>	"c":<<itemClass>>	class of UI component (i.e., widget type); if "c" <<property>> is not specified, it will be automatically derived from value type (i.e., if <<property>> "v" is an array, a number, a boolean, or text, <<itemClass>> will be automatically set to "bin", "num", "btn", or "txt", respectively); if neither "c" nor "v" properties are specified, default component class is "bin" (i.e., [{"id":<<id>>}] is equivalent to [{"id":<<id>>,"c":"bin"}]); item class is tied to item value type (i.e. array, text, number, or boolean), such that "c" <<property>> will change if "v" <<property>> is set to an incompatible value, and vice versa (see "v" <<property>> description for more detail); this property cannot be set for root container	
<<itemClass>>	"bin"		container item; this item's value property "v" can only ever be <<container>>; if "v" property isn't specified, it is set to [] (i.e., this is the default <<container>> component class -- {"add":[{"id":<<id>>,"c":"bin"}]} is equivalent to {"add":[{"id":<<id>>,"v":[]}]}); even if "bin" is empty, human-facing UI software should attempt to display it in some way (e.g., as a spacer), so as to make the human-user experience as close as possible to what AI would experience	
<<itemClass>>	"txt"		text item; this item's value property "v" can only ever be <<text>>; if "v" property isn't specified, it is set to "" (i.e., "" is the default <<text>> component class -- {"add":[{"id":<<id>>,"c":"txt"}]} is equivalent to {"add":[{"id":<<id>>,"v":""}]}	
<<itemClass>>	"num"		numeric item; this item's value property "v" can only ever be <<number>>; if "v" property isn't specified, it is set to 0 (i.e., 0 is the default <<number>> component class -- {"add":[{"id":<<id>>,"c":"num"}]} is equivalent to {"add":[{"id":<<id>>,"v":0}]})	
<<itemClass>>	"btn"		button item; this item's value property "v" can only ever be <<boolean>>; if "v" property isn't specified, it is set to false (i.e., false is the default <<boolean>> component class -- {"add":[{"id":<<id>>,"c":"btn"}]} is equivalent to {"add":[{"id":<<id>>,"v":false}]})	
<<property>>	"id":<<id>>	"id":<<id>>	item id; root-level container has no "id" attribute ("id":null); item <<id>> will be displayed as item caption/title (see <<property>> "cap" below for alternate behavior); WARNING: "id" uniqueness within a given container is up to APP software, and if two items in the same container have the same "id", (1) updating them via "U" command becomes problematic, and (2) user interactions with these items may be indistinguishable (e.g., APP->UI message {"A":[{"id":"click me","v":false},{"id":"click me","v":false}]} will add two "click me" buttons to display, and when user clicks either of them, the UI->APP messages will be indistinguishable, either one reading {"t":<<ums>>,"u":"click me","v":true})	Ex: APP->UI message [{"id":"PI","v":3.14}] will add a numeric item whose id (and title) is "PI", and whose value is 3.14 to display
<<property>>	"value":<<container>>|<<value>>	"v":<<container>>|<<value>>	set item value; setting "v" to null removes the item from display; "v" is a special property whose value type always corresponds to UI component class (i.e., "v" numeric and text values indicate numeric and text UI components, boolean values indicate buttons, and an array indicates a container bin), so changing "v" <<property>> to a different value type will also change the UI component accordingly (e.g., APP->UI message [{"id":"X","v":3.14}] will add a numeric item X whose value is 3.14 to display, and a follow-up APP->UI message {"U":"X","v":"Pi"} will change the component from a numeric to a text element that says "Pi")	Ex: Ex: APP->UI message [{"id":"PI","v":3.14}] will add a numeric item whose id (and title) is "PI", and whose value is 3.14 to display; Ex: {"U":0,"v":null} removes the first item on display
<<Command>>	"!update":<<uid>>	"U":<<uid>>	update; this <<Command>> is only valid for container-type items; find and update item with the specified <<uid>> (recursive search, starting at current container); use this command only at root level (e.g., {"U":"my item","v":"hello world"}) or as a <<qUpdate>> inside a queue list (e.g., {"U":"my container","Q":[{"U":0,"v":"a"},{"U":1,"v":"b"},{"U":2,"v":"c"}]}), NOT inside a "value" or "add" <<container>> of declarations (i.e., {"value":[{"id":"my item","value":"hello"},{"U":"my item","value":"goodbye"}]} is NOT correct and may lead to unexpected results, whereas {"value":[{"id":"my item","value":"hello"}],"queue":[{"U":"my item","value":"goodbye"}]} is the correct way to add a label titled "my item" whose text is "hello", and then immediately change its text to "goodbye")	Ex: {"U":"my item","v":"hello world"} will find "my item" and change its value to "hello world"; Ex: {"U":["buttons",0],"v":null} will find a container named "buttons" and delete the first item in this container; Ex: {"U":"my container","Q":[{"U":0,"v":"a"},{"U":1,"v":"b"},{"U":2,"v":"c"}]} will find "my container", and change its first, second, and third item values to "a", "b", and "c", respectively
<<Command>>	"~add":<<container>>|<<value>>	"A":<<container>>|<<value>>	add to current value (or toggle value); <<property>> "value" is processed before <<Command>> "~add"; for container-type items each <<item>> in <<container>> is added to current container; for text items, "A":<<text>> appends <<text>> to current text value; for numeric items, "A":<<number>> adds <<number>> to current numeric value; for boolean items, "A":<<value>> toggles the boolean value no matter what <<value>> is specified	Ex: APP->UI message {"v":["hello"],"A":["world",{"id":"Click me","v":false}]} is equivalent to {"v":["hello","world",{"id":"Click me","v":false}]}); Ex: APP->UI message {"v":[{"v":"hello","A":" world"}]} is equivalent to {"v":["hello world"]}); Ex: APP->UI message {"v":[{"v":7,"A":11}]} is equivalent to {"v":[18]}); Ex: APP->UI message {"v":[{"c":"opt","id":"Subaru","v":true,"A":1},{"c":"opt","id":"Tesla","v":false,"A":1}]} is equivalent to {"v":[{"c":"opt","id":"Subaru","v":false},{"c":"opt","id":"Tesla","v":true}]}
<<Command>>	"~~queue":[<<qUpdate>>(,<<qUpdate>>)*]	"Q":[<<qUpdate>>(,<<qUpdate>>)*]	queue of updates or declarations; if current APP->UI message requires multiple commands/updates/declarations to be executed in the same container, use "Q" to list all such updates; "Q" is processed last, after all other commands/properties in current <<pList>> are executed	Ex: APP->UI message {"Q":[{"U":"A","v":"a"},{"U":"B","v":"b"}]} will find item "A" and set its value to "a", and then will find item "B" and set its value to "b"; Ex: {"U":"my container","Q":[{"U":0,"v":"a"},{"U":1,"v":"b"},{"U":2,"v":"c"}]} will find "my container", and change its first, second, and third item values to "a", "b", and "c", respectively
<<container>>	[(<<item>>(,<<item>>)*)?]		array of item declarations for current container	Ex: APP->UI message {v:["hello","world"]} will clear display and then add two text items to display -- "hello" and "world"
<<item>>	<<value>>|<<container>>|<<pList>>		an <<item>> may be declared by value (<<value>> or <<container>>) or a list of properties (<<pList>>) (i.e., {"v":["hello","world"]} is shorthand for {"v":[{"v":"hello"},{"v":"world"}]})	
<<pList>>	{<<itemProp>>(,<<itemProp>>)*}		list of item properties and commands	
<<qUpdate>>	<<pList>>		list of properties and commands to execute	
<<uid>>	<<id>>|<<index>>|<<ids>>		unique item <<id>>|<<index>>, or a unique array of breadcrumbs to find an item among current container's descendants	
<<id>>	<<text>>		unique item key; <<id>> of root container is null, and cannot be changed; <<id>> text is displayed as item caption/title text (unless the "caption" optional property is specified, see below)	
<<index>>	<<number>>		item index (i.e., order number within the current container); <<number>> must be an integer; item numbering in a container begins at 0; if <<number>> is less than 0, it indicates that item count begins at last item (i.e., <<index>> -1 is the last item in current container, <<index>> -2 is the next-to-last item, etc.)	
<<ids>>	[<<id>>|<<index>>(,<<id>>|<<index>>)*]		a sequence of id's to search; a search by <<ids>> is equivalent to multiple nested searches for <<id>>|<<index>> (i.e., {"U":["A","B","C"],...} = {"U":"A","Q":[{"U":["B","C"],...}]} = {"U":"A","Q":[{"U":"B","Q":[{"U:"C",...}]}]})	Ex: APP->UI message {"U":["id1","id2"],"v":null} will find container "id1", then within that container find a descendent item "id2" and delete it
<<value>>	<<text>>|<<number>>|<<boolean>>		item value may be text, number, boolean (booleans signify buttons/options)	
<<value>>	null		setting item value to null will delete the corresponding item and remove it from display	Ex: {"!update":0,"value":null} will remove the first item from the display
<<boolean>>	(true)|(false)		true or false boolean value	
<<text>>	*** see JSON string specification at json.org ***		text string	
<<number>>	*** see JSON number specification at json.org ***		numeric value	
<<uint>>	((1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)*)|0		positive integer, or zero	
<<settings>>	*** see JSON object specification at json.org ***		key-value pairs describing non-native UI component settings	
<<ums>>	<<uint>>		time in milliseconds since the handshake message was sent by user-agent software (<<ums>> is 0 at the time when the handshake message is sent)	
<<idPath>>	[<<id>>|<<index>>(,<<id>>|<<index>>)*]		hierarchical partial path to item; the last (right-most) <<id>>|<<index>> in <<idPath>> refers to the actual item where user-event has occurred, with each preceding <<id>>|<<index>> referring to item's parent, its parent's parent, etc.; when forming <<idPath>>, <<id>> should be used instead of <<index>> for any item that has an "id" property, and <<index>> should be used for any item that has no "id" property; <<index>> returned via <<idPath>> is always <<uint>>, never a negative number; <<idPath>> only needs to include enough parent id's so as to provide a unique path to item (i.e., if any <<id>> in <<idPath>> is unique in display, its parents do not need to be included)	Ex: UI->APP message {"u":["buttons","button 1"],"v":true,"t":<<ums>>} signifies that "button 1" inside the "buttons" container was clicked by the user; Ex: UI->APP message {"u":["my items",0,2],"v":true,"t":<<ums>>} means that the third item inside the first item of the "my items" container was toggled/clicked by the user
-	-	-	-	-
everything above is core-UINL (4 UI component classes, 3 properties, 5 commands); all user-agent software must be able to handle the format specified above for simple text+button tasks				
everything below is extended-UINL -- optional UI software features that enable more advanced UI interactions				
if any of the UI features below are required for essential app functionality, this should be specified via the "!!require" <<uiDirective>>; if application requires property values that user-agent software cannot handle, user-agent software can disconnect				
Processing Order:			UI->APP options are processed by UI software in ascending ASCII character sort order of long-form property/command names (not shorthand names): pre-scheduling directives ("!!require", "!async", "!error", "!state", "!style", "!task", "!templates"), scheduling commands ("!time", "!timeDelay", "!timeInterval", "!timingCancel", "!timingName", "!trigger"), search commands ("!update", "!updateChildren", "!updateDeep"), post-scheduling commands ("!~loading", "!~move", "!~open", "!~save"), "Class", all other generic <<property>>'s, late-processing commands ("~add", "~addTags", "~properties", "~request", "~~queue"), animation properties ("ª<<propName>>", "±<<propName>>")	
-	-	-	-	-
### Label Name	### Grammar	### Shorthand	### Description	### Example
<<required>>	<<propName>>:<<values>>		specify properties/commands (and property values) necessary for this application; for any <<propName>> where its value can be an array or associative array (e.g. "R", "on"), <<values>> specifies which names are allowed in said array, (e.g. {"!!require":{"on":["k","pc"]}} signifies that UI software must be able to capture/process key-down and click events)	Ex: {"!!require":{"tag":[],"Class":["grid","win"]}} says that UI software must be able to handle the "tag" property, and must be able to handle "grid" and "win" as potential values for the "Class" property
<<required>>	"!async":[]	"&":[]	declare that app is asynchronous; if application software never sends the <<uiDirective>> "!!require"{..."!async":[]...} or "!!require"{..."&":[]...}, user-agent software will assume that message protocol is synchronous, such that each UI->APP message will be treated as a request by the application, and will be followed immediately by one, and only one, APP->UI response message	
<<required>>	"of":[(<<overlapFunction>>(,<<overlapFunction>>)*)?]		specify which overlap functions are required for this application	Ex: {"!!require":{"of":["bb","r","e","BB"],"rot":[]}} says that UI software must be able to handle 2d rotations and collision detection between post-rotation 2d bounding boxes, 2d rotated rectangles, 2d rotated ellipses, and 3d post-rotation bounding boxes
<<propName>>	*** property name: the part to the left of the colon in the <<property>> or <<Command>> expression (e.g. "cap", "Td", "x") ***			
<<userPropName>>	*** userProp name: the part to the left of the colon in the <<userProp>> expression (e.g. "v", "pc", "error") ***			
<<values>>	[(<<value>>(,<<value>>)*)?]			
<<property>>	<<propName>>:null		remove/reset property (i.e. clear or reset property to default behavior); this doesn't hold for properties "c" and "v" ("v":null will delete current item, "c":null does nothing)	
<<property>>	<<propName>>:{.*}		partially update property; only for <<property>>'s whose values are mapped arrays (e.g., "on", "throt", "df", "axisx", "axisy", "ª<<propName>>") and for <<uiDirective>>'s "tem" and "task" (not for <<uiDirective>> "!!require" -- once a feature is required, it cannot be un-required)	Ex: APP->UI message {"on":{"k":[]}} followed by APP->UI message {"on":{"ku":[]}} will add both keydown and keyup event-listeners to the display (rather than replacing the keydown with the keyup event-listener)
<<uiDirective>>	"!error":<<text>>	"err":<<text>>	error or warning (or debugging) message to be dumped into UI error stream	
<<uiDirective>>	"!async":<<uint>>	"&":<<uint>>	time in milliseconds since the initial UI->APP message (i.e., handshake) was received by the application; for asynchronous tasks it is good practice to include this <<uiDirective>> in every APP->UI messages; use {"!!require":{..."ts":[]...}} to announce to user-agent software that the application will employ asynchronous protocol (otherwise user-agent software will assume that message protocol is synchronous, such that each UI->APP message will be treated as a request by the application, and will be followed immediately by one, and only one, APP->UI response message)	
<<uiDirective>>	"!task":{<<instructions>>(,<<instructions>>)*}	"task":{<<instructions>>(,<<instructions>>)*}	task instructions; "task" may be called multiple times, updating each <<instructions>> separately (e.g., APP->UI message {"task":{"end":[{"id":"Round","v":{">>":10}}]},"good":[{"id":"Gold"}]} instructs user that task ends after Round 10 and that the goal is to seek items named "Gold", and a follow-up APP->UI message {"task":{"end":[{"id":"Round","v":{">>":12}}]}} will partially update those instructions, informing user that instead of task ending after Round 10, it will end after Round 12); if task instruction specification is essential to the task, use "!!require":{..."task":[(<<taskOptionName>>(,<<taskOptionName>>)*)?]...} where <<taskOptionName>> is a name of <<instructions>>, <<condProp>>, <<operator>>, or <<refop>> used in instructions (i.e., "good", "bad", "win", "loss", "end", "rules","task", "and", "=", "~", ">>", ">", "<", ">=", "<=", "!=", "uid", "prop", "+", "*", "^", "min", "max")	Ex: {"task":{"good":[{"id":"Temperature","v":{">":60,"<":80,"~":72}}]}} would instruct user to keep Temperature between 60 and 80, the closer to 72, the better
<<uiDirective>>	"!templates":{<<template>>(,<<template>>)*}	"tem":{<<template>>(,<<template>>)*}	templates for quick item declarations and updates (i.e., named sets of property updates that may be used via the "Q" command or "df" and "fs" properties); changing a <<template>> does not affect items that were previously created/updated using this template; "!templates" may be called multiple times, updating each <<template>> separately	Ex: APP->UI message {"tem":{"del-2":{"Td":2,"v":null},"v":[{"v":"a","Q":["del-2"]},{"v":"b","Q":["del-2"]},{"v":"c","Q":["del-2"]}]}} will add a template called "del-2" that removes the item after 2sec, and will add three text items ("a", "b", and "c"), each of which will be removed 2sec after they are displayed
<<template>>	<<templateName>:<<pList>>		<<pList>> is a list of properties/commands to be executed whenever this template is employed; APP software should avoid naming templates with a reserved property or command name	Ex: APP->UI message {"tem":{"del-2":{"Td":2,"v":null},"v":[{"v":"a","Q":["del-2"]},{"v":"b","Q":["del-2"]},{"v":"c","Q":["del-2"]}]}} will add a template called "del-2" that removes the item after 2sec, and will add three text items ("a", "b", and "c"), each of which will be removed 2sec after they are displayed
<<templateName>>	<<text>>		unique name for a template	
<<qUpdate>>	<<templateName>>		template name, referring to an existing <<template>>; use {"!!require":{..."!templates":[]...}} to ensure that UI software can handle such <<qUpdate>>'s	
<<uiDirective>>	"!style":<<text>>	"style":<<text>>	load preferred style template; use "!style" to specify preferred spacing, fonts, colors, background images, sound-effects, sprite animation, and other aspects of aesthetic appeal in human-centric UI (i.e., features that would not be needed for computational agents to correctly determine UI functionality); <<text>> is likely a set of CSS rules or a URL of a style-sheet, though it may contain other styling resource specific to a given UI software framework (e.g. javascript); "!style" directive may be called multiple times to load multiple parts of a style template	
<<uiDirective>>	"!time":<<ums>>	"T":<<ums>>	time scheduling for current declaration/update; used to delay the processing of the current update until user time has reached the specified <<ums>>; scheduling commands are processed first, before any other commands/properties in current <<pList>>, and are executed in the following order: "T", "Tr", "Td", "Ti"	Ex: {"Q":[{"T":1000,"A":["hello"]},{"T":2000,"A":["world"]}]} will add the text "hello" to display exactly 1.0s after handshake was sent, and then add the text "world" exactly 2.0s after handshake was sent
<<uiDirective>>	"!trigger":{(<<userPropTrigger>>(,(<<userPropTrigger>>)*)?}	"Tr":{(<<userPropTrigger>>(,(<<userPropTrigger>>)*)?}	trigger rule for current update; current update/declaration is triggered whenever UI->APP message matches the specified <<userProp>>'s; use "Tr":{} as a wildcard to trigger whenever any UI->APP message is sent; use "Tr":{...<<userPropName>>:{}...} as a wildcard to trigger whenever a UI->APP message includes <<pName>>, regardless of its corresponding value; use "Tr":{..."u":null...} to set up a trigger for root container events; scheduling/trigger commands are processed first, before any other commands/properties in current <<pList>>, and are executed in the following order: "T", "Tr", "Td", "Ti"	Ex: {"Tr":{"v":true},"in":-1} will disable all display interactions whenever any button is clicked (useful to prevent accidental repeat-clicks in asynchronous tasks); Ex: {"Tr":{"u":"Submit","v":true},"A":[{"c":"win","id":"Loading...","mod":1}]} will bring up a "Loading..." popup window when user clicks the "Submit" button
<<Command>>	"!timeDelay":<<number>>	"Td":<<number>>	timed delay (i.e., timeout) prior to update; <<number>> is the number of seconds (according to user-agent clock) to delay; scheduling commands are processed first, before any other commands/properties in current <<pList>>, and are executed in the following order: "T", "Tr", "Td", "Ti"	Ex: APP->UI message {"A":[{"v":"hello","Q":[{"Td":2,"v":null}]}]} would add text "hello" to screen, and then remove it 2 seconds later
<<Command>>	"!timeInterval":<<number>>	"Ti":<<number>>	time interval for current update; <<number>> is the number of seconds (according to user-agent clock) to delay between update executions; if <<number>> is less than UI refresh rate, interval will fire at the speed of UI refresh rate; scheduling commands are processed first, before any other commands/properties in current <<pList>>, and are executed in the following order: "T", "Tr", "Td", "Ti"; "Ti" does not cause a delay before initial update (use "Td" to add that delay)	Ex: APP->UI message {"Ti":2,"Tn":"polling","R":[]} will execute the "R" command immediately (sending a UI->APP message {"t":<<ums>>,"r":{}}), and then again every two seconds until/unless "Tc":"polling" or "Tc":{} <<uiDirective>> is found in a future update
<<Command>>	"!timingName":<<text>>	"Tn":<<text>>	timer or trigger name; naming an update scheduled via "T", "Tr", "Td", and/or "Ti" commands enables its later cancellation via <<uiDirective>> "Tc":<<text>>	Ex: APP->UI message {"v":[{"id":"candles","v":0,"Q":[{"Td":10,"v":1,"Tn":"t1"},{"Td":20,"v":2,"Tn":"t2"}]}]} would add item "candles" with value 0 to display, and set up named timers to change the value of "candles" to 1 after 10sec and to 2 after 20sec, such that a follow-up APP->UI message {"Tc":"t1"} would cancel the update scheduled to occur in 10s and {"Tc":"t2"} would cancel the update scheduled to occur in 20s (APP->UI message {"Tc":{}} would cancel all scheduled updates regardless of name)
<<uiDirective>>	"!timingCancel":<<text>>	"Tc":<<text>>	cancel named scheduled updates; <<text>> is the name of the update, as specified via "Tn" <<Command>>	Ex: APP->UI message {"v":[{"id":"candles","v":0,"Q":[{"Td":10,"v":1,"Tn":"t1"},{"Td":20,"v":2,"Tn":"t2"}]}]} would add item "candles" with value 0 to display, and set up named timers to change the value of "candles" to 1 after 10sec and to 2 after 20sec, such that a follow-up APP->UI message {"Tc":"t1"} would cancel the update scheduled to occur in 10s and {"Tc":"t2"} would cancel the update scheduled to occur in 20s
<<uiDirective>>	"!timingCancel":{}	"Tc":{}	cancel all updates scheduled via "T", "Tr", "Td", and "Ti" commands (regardless whether they were named)	
<<Command>>	"!updateChildren":{(<<matchByVal>>(,<<matchByVal>>)*)?}	"U\*":{(<<matchByVal>>(,<<matchByVal>>)*)?}	update multiple child items of current container; this <<Command>> is only valid for container-type items; select all items that match all <<matchByVal>>'s in current container and update them according to current property specifications; update commands are processed in the following order: "U", then "U**", then "U*", and these are processed after scheduling commands (T, Tr, Td, Ti, Tn, Tc), but before any other property setting or command is applied; if there are no <<matchByVal>>'s (i.e., "U*":{}), all items are selected	Ex: {"U*":{},"tag":["critical"]} sets tag of all items in root to "critical"
<<Command>>	"!updateDeep":{(<<matchByVal>>(,<<matchByVal>>)*)?}	"U\*\*":{(<<matchByVal>>(,<<matchByVal>>)*)?}	Update multiple descendants of current container, recursively; this <<Command>> is only valid for container-type items; select all items that match all <<matchByVal>>'s in current container and all its children, recursively, and update them according to current property specifications; update commands are processed in the following order: "U", then "U**", then "U*", and these are processed after scheduling commands (T, Tr, Td, Ti, Tn, Tc), but before any other property setting or command is applied; if there are no <<matchByVal>>'s (i.e., "U**":{}), all items are selected	Ex: {"U**":{},"tag":["critical"]} sets tag of all items in display to "critical"; Ex: {"U":"My numbers","U**":{"c":"num"},"tag":["critical"]} sets tag of all numeric items in "My numbers" container or any of its descendant containers to "critical"
<<uiDirective>>	"!~open":"<<url>>"	"open":"<<url>>"	open (or download) external resource	Ex: {"!~open":"https://google.com"} will open google website in a separate window; Ex: {"!~open":"https://reqres.in/api/users","fmt":"json"} will download sample json data from reqres.in website
<<uiDirective>>	"!~save":[<<text>>,<<text>>]	"save":[<<text>>,<<text>>]	save text/data to user's local file; the first <<text>> parameter is the filename, and the second is the text/data to be saved	Ex: APP->UI message {"!~save":["hello.txt","hello world"]} will cause UI software to open a prompt to save a text file hello.txt, whose content will be "hello world"
<<uiDirective>>	"!~save":[<<text>>,<<text>>,"base64"]	"save":[<<text>>,<<text>>,"base64"]	save binary data to user's local file; the first <<text>> parameter is the filename, and the second is the base64-encoded binary data to be saved; UI software will decode data from base64 to binary before saving to a file	Ex: APP->UI message {"!~save":["hello.txt","aGVsbG8gd29ybGQ="]} will cause UI software to open a prompt to save a file hello.txt, whose content will be "hello world"
<<Command>>	"!~loading":1|0	"loading":1|0	"!~loading":1 shows a wait/loading modal on top of the current container (usually semi-transparent), preventing interaction with all items in this container; "!~loading":0 (or "!~loading":null) removes the loading modal, re-enabling interaction with display	
<<Command>>	"!~move":<<uid>>	"M":<<uid>>	Move item from its current parent to container specified by <<uid>>; <<Command>> "M" is always processed before <<property>> "i"	Ex: APP->UI message {"A":[{"id":"A","v":["a","b"]},{"id":"B","v":[]}],"Q":[{"U":["A",1],"M":"B"}]} will add containers A and B to display, where container A has text "a" and "b" inside, and B has nothing, and then move second item from A into B, resulting in the following UIOM: {"v":[{"c":"bin","id":"A","v":[{"c":"txt","v":"a"}]},{"c":"bin","id":"B","v":[{"c":"txt","v":"b"}]}]}
<<Command>>	"~addTags":[<<tag>>(,<<tag>>)*]	"Atag":[<<tag>>(,<<tag>>)*]	Add tags to item's "tag" <<property>>; each <<tag>> indicates the item is semantically [and thus visually] distinct from items that do not share this <<tag>>; if <<tag>> is not already in this item's "tag" <<property>>, it is added; if this item has no "tag" <<property>> or "tag" is an empty-list, then "Atag":[<<tag>>(,<<tag>>)*] is equivalent to "tag":[<<tag>>(,<<tag>>)*]; if <<property>> "tag" and <<Command>> "Atag" are in the same <<pList>>, "tag" is processed before "Atag"	
<<Command>>	"~properties":{<<propName>>:<<values>>(,<<propName>>:<<values>>)*}	"<-":{<<propName>>:<<values>>(,<<propName>>:<<values>>)*}	assign property values in a series; for container-type items only; each <<value>> in <<values>> gets assigned to this container's respective child's <<propName>> property; if <<property>> "v" or <<Command>> "A" are in the same <<pList>> as <<Command>> "<-", "<-" is processed after both "v" and "A"	Ex: APP->UI message {"A":[{"c":"data","plt":"xy","v":[3,5,7,1],"<-":{"x":[0.5,2.1,3.2,4.5]}}]} is equivalent to APP->UI message {"A":[{"c":"data","plt":"xy","v":[{"v":3,"x":0.5},{"v":5,"x":2.1},{"v":7,"x":3.2},{"v":1,"x":4.5}]}]}
<<Command>>	"~request":[(<<req>>(,<<req>>)*)?]	"R":[(<<req>>(,<<req>>)*)?]	Request info; [(<<req>>(,<<req>>)*)?] describes the information to be sent back to application software; if no specific information is requested (i.e., "R":[]), a message with <<userProp>> "r" is still returned (e.g., APP->UI message {"R":[]} will be ensued by UI->APP message {"t":<<ums>>,"r":{}}); for items that have children, <<req>> "v" returns the child array in accordance with the display object-model (e.g., APP->UI message {"v":["hello",12],"R":["v"]} will be ensued by UI->APP message {"t":<<ums>>,"r":{"v":[{"c":"txt","v":"hello"},{"c":"num","v":12}]}}); if <<req>> information is unavailable, the UI->APP message must include <<req>>:null for the corresponding <<req>> (i.e., every requested <<req>> text must be included as a key in the ensuing UI->APP message, even if it's not a known name of a property); "R" command is executed after all other commands/properties in current <<pList>>, but before "Q" ("Q" is always processed last)	Ex: APP->UI message {"v":[{"id":"hello","v":"world","tag":["s1"],"R":["v","tag","wh","__foobar"]}]} will cause "hello":"world" text item to be added to display, and immediately after will send UI->APP message {"t":<<ums>>,"u":"hello","r":{"v":"world","tag":["s1"],"wh":[<<number>>,<<number>>],"__foobar":null}}
<<Command>>	<<eventInfo>>		simulate a user-generated event; this is useful for triggering updates bound to a "!trigger" or, in the case where <<eventInfo>> is "ctx":[(<<xy>>)?], for bringing up a <<contextMenu>> for items that have "onContext":<<contextMenu>> property	
<<itemClass>>	"hold"		this item is a hold-down button -- a special <<boolean>> that sends <<userProp>> "v":true when pressed and "v":false when released	
<<itemClass>>	"opt"		this item is a selectable option -- a special <<boolean>> that can be selected (setting <<property>> "v" to true) and deselected (setting <<property>> "v" to false) with alternating clicks	
<<itemClass>>	"time"		this item is a timespan field -- a special <<number>> item whose value represents a number of seconds; use <<numProp>> "step" to control time precision (e.g., use "step":60 to exclude seconds or "step":1 to exclude milliseconds)	Ex: APP->UI message {"A":[{"c":"time","v":12345.67}]} adds the time 3:25:45.670 to the display
<<itemClass>>	"dt"		this item is a datetime field -- a special <<number>> item whose value represents number of seconds since epoch; default value for this item is current datetime (e.g., an APP->UI message {"A":[{"c":"dt"}]} received on 04/08/2021 at 07:11:23.364 PM (localtime) will be instantiated with the value 1617909083.364, thus displaying date/time 2021-04-08 07:11:23.364 PM); use <<numProp>> "step" to control datetime precision (e.g., use "step":60 to exclude seconds, "step":86400 to exclude time (just show the date), or "step":1 to exclude milliseconds); use <<numProp>> "unit" to provide context for current timestamp (e.g., timezone)	Ex: APP->UI message {"A":[{"c":"dt","v":1613135520,"step":60,"unit":"UTC-05:00"}]} adds the date/time 2021-12-12 1:12pm UTC-05:00 to the display
<<itemClass>>	"math"		this item is a mathematical value or formula -- a special <<text>> item that follows AsciiMath syntax (see http://asciimath.org/ for more detail); use "i" (character i in double-quotes) or UTF character ⅈ to denote imaginary number (i.e., square root of -1)	Ex: APP->UI message {"A":[{"c":"math","id":"Special Relativity","v":"E=mc^2"}]} adds a math formula to display title Special Relativity, with the value "E=mc²"; Ex: APP->UI message {"A":[{"id":"Number Examples","v":[{"id":"whole","v":1},{"id":"real","v":1.1},{"c":"math","id":"fraction","v":"1/2"},{"c":"math","id":"complex","v":"(2+3\"i\")"},{"c":"math","id":"constant","v":"pi"}]}]},{"c":"math","id":"infinity","v":"oo"}]}]} will add a Number Examples bin to display, containing examples of whole, real, fraction, complex number, a mathematical constant, and infinity
<<itemClass>>	"doc"		this item is an embedded document - its a special <<text>> item that includes markup syntax; default markup language is HTML (use "fmt" property for alternate behavior; for example "fmt":"md" signifies this doc uses markdown syntax); this should only be employed for displaying documents, not functional UI components, and with the assumption that many machine agents will ignore markup tags	Ex: APP->UI message {"A":[{"c":"doc","v":"<b>this text is bold</b>"}]} will add bold text "this text is bold" to display; Ex: APP->UI message {"A":[{"c":"doc","fmt":"md","v":"_this text is underlined_"}]} will add underlined text "this text is underlined" to display
<<itemClass>>	"file"		this item is a file chooser - its a special <<text>> item whose "input" property is 1 by default (i.e., interactive by default), and whose value is set after user chooses some file(s); by default file-chooser only allows choosing a single file, and after the user chooses a file from their storage device a UI->APP message {"t":<<ums>>,"u":<<uid>>,"v":<<base64>>} is sent, where <<base64>> is the base64 representation of file contents (for alternate behavior, see <<fileProp>> "accepts"); if <<interactProp>> "go":1 is used for this item, the UI->APP message with file contents is not sent until after the "go" button is clicked	
<<itemClass>>	"rgb"		this item is a color -- a special <<text>> item whose value is a 6-character hexadecimal value, representing RGB color; for human users this is likely displayed as the actual color, rather than a hex string	Ex: APP->UI message {"A":[{"c":"rgb","v":"40e0d0","in":1}]} will add a color picker to display, with its current value set to turquoise
<<itemClass>>	"drop"		this item is a dropdown container (usually a dropdown menu) -- a special <<container>> whose content is folded by default (i.e., "fold":2), and when it is unfolded (i.e., "fold":1) it is drawn hovering above other content, and is automatically folded again when this item loses focus or when one of its inputs is edited or toggled; this item cannot have "fold":0 property -- its "fold" property is always 1 or 2; every item inside a "drop" container is a button (i.e., "Class":"btn") by default (use "defaults" property for alternate behavior)	Ex: {"A":[{"id":"File","c":"drop","v":[{"id":"Open"},{"id":"Save","in":0},"",{"id":"Recent","c":"drop","v":[{"id":"File 1"},{"id":"File 2"}]}]}]} adds a clickable "File" item to display, and whenever "File" is clicked, a menu is shown with a clickable "Open" button, a disabled "Save" button, a spacer, and a "Recent" submenu with clickable items "File 1" and "File 2"
<<itemClass>>	"ctx"		this item is a context menu -- a special <<container>> that is drawn hovering above other content, and is automatically deleted from display when this item loses focus or when one of its inputs is edited or toggled; every item inside a "ctx" container is a button (i.e., "Class":"btn") by default (use "defaults" property for alternate behavior); if "ctx" item is destroyed as a result of losing focus, a UI->APP message {"t":<<ums>>,"u":<<uid>>,"v":null} is sent	Ex: {"A":[{"id":"my text","v":"hello world"},{"id":"copy-paste","c":"ctx","ref":"my text","v":[{"id":"Copy"},{"id":"Paste"}]}]} adds the text "hello world" to display, as well as a context menu (with buttons Copy, Paste) drawn aligned to the "hello world" text, and Copy or Paste buttons are clicked or user clicks elsewhere on screen, the context menu is deleted from display (sending UI->APP message {"t":<<ums>>,"u":"copy-paste","v":null} if the context menu was destroyed as a result of losing focus)	
<<itemClass>>	"win"		this item is a window/popup -- a special <<container>> that floats freely in its parent container (potentially obscuring view of what's behind it); "win" container position does not cause reflow of its siblings; by default "win" containers do not block interaction with other visible items on display (see "mod" <<winProp>> for alternate behavior); "win" container is able to receive focus (e.g. when it or one of its child items is clicked), and when it does this "win" container's stack-order index (<<property>> "i") is automatically increased maximally (i.e., it becomes last item in its parent container, and thus the top-most item, unobscured by other items); use <<interactProp>> "on":{"fcs":[]} to subscribe to "win" focus in/out events; when this container has no "mod":1 <<winProp>>, human-facing UI software is responsible for enabling interaction with sibling items that may be obscured by this container (this may be done by making "win" item draggable/resizable, via a keyboard shortcut or a toolbar, and/or any other method)	Ex: APP->UI message {"A":[{"c":"win","mod":1,"ds":1,"v":["This is a popup!"]}]} will display a modal (i.e., disabling interactions with other items) popup above all other content, the popup will have "This is a popup!" text inside, and a button to dismiss the popup
<<itemClass>>	"one"		this item is a container with one child whose content is visible and other children whose content is hidden (usually represented to humans as tabs, accordion, or a carousel) -- a special <<container>> whose children are all "bin" class items with <<containerProp>> "fold", where one child has <<containerProp>> "fold":1 and the rest of the children have <<containerProp>> "fold":2; by default the first "one" child has <<containerProp>> "fold":1 and the rest of the children have <<containerProp>> "fold":2; setting any "one" child <<containerProp>> "fold":1 will automatically set the rest of the children to "fold":2; user does not have the control to set "fold":2 for any "one" child (cannot hide a visible child), but can set "fold":1 (can show a specific child, thus automatically hiding other children); no UI->APP message is sent when a container in "one" is folded/unfolded (use <<interactProp>> "on":{"fold":[1]} to subscribe to unfold events for each child of "one")	Ex: APP->UI message {"A":[{"c":"one","df":{"on":{"fold":[1]}},"v":[{"id":"A","v":["hello"]},{"id":"B","v":["world"]}]}]} will add a container with two tabs to display, with item "A" being visible (displaying text "hello"), and if the user clicks on the second tab, item "B" will show (displaying text "world")
<<itemClass>>	"grid"		this item is a grid/table -- a special <<container>> that contains only "bin" class items, each of which will be a row in the grid; grid cells cannot be "win" class; null <<item>> declarations in the middle of grid-row <<container>> array declarations do *NOT* create empty grid cells -- these are ignored (just as they would be for any "bin" class items); deleting an item from a grid-row shifts the rest of row contents left to take up the space of the deleted item; each grid-row "id" or "cap" option is used as row header; human-facing UI software may include special visualization for grid (header row/col may be frozen, while other rows/cols are scrollable; if two consecutive header cells are identical, those header cells may be merged; etc.)	Ex: APP->UI message {"A":[{"c":"grid","id":"personnel","v":[["john",39,"m"],["mary",28,"f"]],"head":["name","age","gender"]}]} will add a "personnel" table with a header row and two records (john, mary) to display
<<itemClass>>	"<span"		this item is a grid cell merged with a cell to its left -- a special blank item inside a grid row, indicating that an item directly to its left spans rightward into this cell's space; this item has no working <<property>>'s	
<<itemClass>>	"^span"		this item is a grid cell merged with a cell above it -- a special blank item inside a grid row, indicating that an item directly above it spans downward into this cell's space; this item has no working <<property>>'s	
<<itemClass>>	"url"		this item is a frame displaying external resources -- an item whose value property must be "<<url>>", where the <<url>> points to a resource that will be displayed as an inline frame; <<interactProp>> "in":-1 disables user interactions with frame contents	Ex: APP->UI message {"A":[{"c":"url","v":"/images/image1.jpg"},{"c":"url","v":"https://google.com"}]} will add an image /images/image1.jpg and a frame displaying google.com website to display
<<itemClass>>	"media"		this item is embedded playable media (i.e., audio/video/slideshow) -- an item whose value must be "<<url>>", where <<url>> points to a media resource with playback capabilities; by default this item is interactive (subscribe to <<event>> "play", "at", and "av" to listen for media interaction events); <<interactProp>> "in":-1 disables user interactions with the specified media (i.e., app software may still start/end playback, but user-software cannot)	Ex: APP->UI message {"A":[{"c":"media","v":"/video/v1.mp4","play":1,"in":-1}]} will add a non-interactive playing video to display
<<itemClass>>	"plot"		this item is a 2d plot/chart -- a special <<container>> that contains only "data" class items; there is no need to specify "c":"data" for each item inside "plot", as this is presumed by UI software; all "data" series in this container will be drawn on the same plot and will share this item's "axisx" and "axisy" properties	
<<itemClass>>	"data"		this item is a series of data points -- a special <<container>> that contains only "dp" class items; there is no need to specify "c":"dp" for each item inside "data", as this is presumed by UI software	
<<itemClass>>	"dp"		this item is a data point on a chart -- a terminating numeric item inside each "data" container; this item is ignored if used outside of "data" containers	
<<itemClass>>	"2d"		this item is a 2d graphics viewport -- a special <<container>> whose children are "gr" items; there's no need to specify "c":"gr" for children of "2d" (because "gr" is the default and only component class for any child of "2d")	
<<itemClass>>	"3d"		this item is a 3d graphics viewport -- a special <<container>> whose children are "gr" items; there's no need to specify "c":"gr" for children of "3d" (because "gr" is the default and only component class for any child of "3d")	
<<itemClass>>	"grg"		this item is a group of graphical items -- a special <<container>> whose children are "grg" or "gr"; "grg" is not meant to be drawn on display, only its descendant "gr" and "l" items are drawn, thus all normally visualizable and interactive item properties ("cap", "ef", "af", "tag", "tip", "ctx", "ref", and <<interactProp>>'s) are ignored for "grg" container; there's no need to specify "c":"gr" for children of "grg" (because "gr" is the default component class for any item inside "grg"); for descendants of "2d", later "grg" containers (i.e., those with a higher index property "i") are drawn later, and are drawn on top of earlier-specified "grg" containers (i.e., those with a lower index property "i"); items inside "grg" should use coordinates relative to the "x"/"y" of this "grg" item; "x"/"y" properties of "grg" indicate the translation of this group, as well as the origin point for rotation and scaling	
<<itemClass>>	"gr"		this a graphical node inside a 2d or 3d container -- a special <<container>> that contains only "l" items (i.e., links); this item must be a child of "2d" or "3d" or "grg" container; each child of "gr" is a link to another "gr" item within this "2d" or "3d" container; there is no need to specify "c":"l" for children of "gr" (because "l" is the default and only class type allowed inside the "gr" container); use <<property>> "tag" to provide visual styling for "gr" items (e.g., background color, sprite images); for descendants of "2d", later "gr" items are drawn later, and are thus shown in front of earlier-specified "gr" items within the same "grg"	
<<itemClass>>	"l"		this item is a line/link in a "2d" or "3d" graphical container -- a terminating item inside a "gr" container; the value property of "l" items is a partial <<uid>> of another item within this "2d" or "3d" graph -- it specifies a unique path to another item within this item's root "2d" or "3d" graph container; if this item has no value, it links to its parent "gr" item's next sibling, if one exists (i.e., APP->UI message {"A":[{"c":"2d","w":50,"h":50,"df":{"v":[{}]},"v":[{"x":10,"y":10},{"x":25,"y":40},{"x":40,"y":10}]}]} will draw a V shape with vertices at (10,10), (25,40), and (40,10))	Ex: APP->UI message {"A":[{"c":"2d","w":140,"h":140,"df":{"w":20,"h":20},"v":[{"id":"A","x":20,"y":20,"v":["D","E"]},{"id":"B","x":20,"y":60,"v":[{"v":"F","ef":0.1}]},{"id":"C","x":20,"y":100,"v":[{"v":"D","ef":0.5}]},{"id":"D","x":100,"y":20},{"id":"E","x":100,"y":60},{"id":"F","x":100,"y":100}]} would add a 2d container to display with a network graph with nodes A, B, C on the left and D, E, F on the right and weighted links where the weights are 0, 0, 0.1, and 0.5 for links A-D, A-E, B-F, and C-D, respectively
<<property>>	"index":<<index>>	"i":<<index>>	index number for current item; <<index>> is zero-indexed; if <<index>> is negative, it indicates reverse order (i.e., "index":-1 places current item at the end of its parent container, "index":-2 places current item in next-to-last spot in current container, etc.); if another item, X, with index number <<index>> exists in current current container, this item is inserted before X; if no item with <<index>> exists in current container, this item is moved to end of container	Ex: APP->UI message {"v":["a","b","c"]} followed by {"A":[{"v":"x","i":1}]} is equivalent to {"v":["a","x","b","c"]}
<<property>>	"caption":<<captionText>>	"cap":<<captionText>>	visible caption/title (replaces item id as the visible title); <<captionText>> is standard <<text>> with one exception -- it may include inline images (icons) indicated via the following escape sequence: ![<<altTxt>>](<<url>>), where <<altTxt>> is optional text to display if the <<url>> resource is not loading (if no <<altTxt>> is specified and there is an error loading the image, nothing is shown)	Ex: {"A":[{"id":"uploadBtn","c":"btn","cap":"Upload"}]} will add a button to display with caption "Upload"; Ex: {"A":[{"id":"myTxt","value":"hello world","cap":""}]} will add text "hello world" to display, where this text item has an "id" (and thus can be referenced by id later), but has no caption; Ex: {"A":[{"id":"uploadBtn","c":"btn","cap":"![Upload](/images/upload.png)"}]} will add a button to display with caption displaying /images/upload.png icon, and if this icon cannot be loaded, the text "Upload" will be displayed instead
<<property>>	"effect":<<number>>	"ef":<<number>>	effect/strength (i.e., item's importance/prominence); <<number>> must be between -1 and 1 (default is 0); for human users higher effect/strength will make item more visually emphasized (e.g. thicker, brighter, vibrating) and lower strength will make item less visually emphasized (e.g. thinner, dimmer, smaller font); UI for human users will not always be capable of displaying fine-grained differences between different effect strengths, so using just the 3 possible integer values (-1,0,1), or even 5 values (-1,-0.5,0,0.5,1), is far better than using 6 or more floating point values for the "ef" <<property>>; when to use "ef" vs "af" vs "tag": use "tag" to indicate category differences, use "ef" to indicate critical level of information, use "af" to indicate positive or negative sentiment	Ex: APP->UI message {"A":[{"v":"Important!","ef":1},{"v":"not that important","ef":-1},{"v":"Critical Error!","ef":1,"af":-1}]} will add three text item to display, one of them with more importance than normal, one with less importance than normal, and one with high importance and a negative connotation
<<property>>	"affect":<<number>>	"af":<<number>>	affect/sentiment (i.e., item's positive or negative valence); <<number>> must be between -1 and 1 (default is 0); for human users higher affect value will make item more visually positive (e.g., blue or green) and lower strength will make item less visually emphasized (e.g., red or orange); UI for human users will not always be capable of displaying fine-grained differences between different effect strengths, so using just the 3 possible integer values (-1,0,1), or even 5 values (-1,-0.5,0,0.5,1), is far better than using 6 or more floating point values for the "af" <<property>>; when to use "ef" vs "af" vs "tag": use "tag" to indicate category differences, use "ef" to indicate critical level of information, use "af" to indicate positive or negative sentiment	Ex: APP->UI message {"A":[{"v":"i like it","af":1},{"v":"don't like it","af":-1},{"v":"Critical Error!","ef":1,"af":-1}]} will add three text item to display, one of them with a positive connotation, one with a negative connotation, and one with high importance and a negative connotation
<<property>>	"tag":[<<tag>>(,<<tag>>)*]		set item tags to indicate emphasis; each <<tag>> indicates the item is semantically [and thus visually] distinct from items that do not share this <<tag>>; when to use "ef" vs "af" vs "tag": use "tag" to indicate category differences, use "ef" to indicate critical level of information, use "af" to indicate positive or negative sentiment	
<<property>>	"tip":<<text>>		tooltip text to display when user needs more information about current item (e.g. for human users this is usually displayed when user hovers over the item)	
<<property>>	"reference":[<<uid>>(,<<uid>>)*]	"ref":[<<uid>>(,<<uid>>)*]	references to other items describing this item (e.g. footnotes, citations)	Ex: APP->UI message {"v":[{"id":"Name","v":"","in":1,"ref":["Required"]},{"id":"Email","v":"","in":1,"ref":["Required"]},{"id":"Notes","v":"\n","in":1},{"id":"Required","str":2}]} puts text inputs Name, Email, and Notes on display, as well as an item called Required, and references from Name and Email to Required
<<property>>	"scrollX":<<number>>	"sx":<<number>>	horizontal scrolling for items that may have content exceeding visible width (e.g., "bin", "txt", "win"); <<number>> signifies scroll percentage -- must be between 0 and 100, where "sx":0 signifies that left-most part of content is visible, and "sx":100 signifies that right-most part of content is visible; does not auto-scroll as new content gets added	
<<property>>	"scrollY":<<number>>	"sy":<<number>>	vertical scrolling for items that may have content exceeding visible height (e.g., "bin", "txt", "win"); <<number>> signifies scroll percentage -- must be between 0 and 100, where "sy":0 signifies that top-most part of content is visible, and "sy":100 signifies that bottom-most part of content is visible; does not auto-scroll as new content gets added	
<<property>>	<<interactProp>>		user-interaction options	
<<property>>	<<containerProp>>		options for items of class "bin", "win", "grid", "one", "plot", "2d", "3d", "data", and "gr"	
<<property>>	<<binProp>>		options for bin-like containers -- "bin", "win", "grid", "one", "plot", "2d", "3d"	
<<property>>	<<numProp>>		numeric-type item options ("num", "dt", "time")	
<<property>>	<<txtProp>>		"txt" and "doc" item options	
<<property>>	<<holdProp>>		"hold" item options	
<<property>>	<<optProp>>		"opt" item options	
<<property>>	<<ctxProp>>		"ctx" item options	
<<property>>	<<winProp>>		"win" item options	
<<property>>	<<gridProp>>		"grid" item options	
<<property>>	<<fileProp>>		"file" item options	
<<property>>	<<mediaProp>>		"media" item options	
<<property>>	<<plotProp>>		"plot" item options	
<<property>>	<<dataProp>>		"data" item options	
<<property>>	<<dpProp>>		"dp" item options	
<<property>>	<<viewportProp>>		"2d" and "3d" item options	
<<property>>	<<grgProp>>		"grg" item options	
<<property>>	<<grProp>>		"gr" item options	
<<property>>	<<lProp>>		"l" item options	
<<property>>	<<animation>>		animation options	
<<userProp>>	"r":{<<reqInfo>>(,<<reqInfo>>)*}		information returned to application software, as requested via the "R" command or the "r" <<aniOpt>> or the "r" <<ovrOpt>>	
<<userProp>>	<<eventInfo>>		events triggered by user input, user action, user software changes, media playback, or animation	Ex: APP->UI message {"on":{"k":[]}} will add a key-down event-listener, and when the user hits the left-arrow key, a UI->APP message is sent {"t":<<ums>>,"k":"ArrowLeft"}
<<userProp>>	"ul":<<uid>>		leaf id for current event; this is the id of the item where current event occurred -- a descendant of a container listening for this event; see <<interactProp>> "eventLeaf" for more details	
<<userProp>>	"m":<<uid>>		indicate that user has moved current item to container specified by <<uid>>	Ex: UI->APP message {"t":<<ums>>,"u":"my item","m":"some target container","i":0} means that item "my item" was moved to container "some target container", and is now the first item in that container
<<userProp>>	"i":<<uint>>		indicate new index for item that was moved	Ex: UI->APP message {"t":<<ums>>,"u":"my item","m":"some target container","i":0} means that item "my item" was moved to container "some target container", and is now the first item in that container
<<userProp>>	"o":<<uid>>		overlap-start event has occurred with item specified via <<uid>>	
<<userProp>>	"e":<<uid>>		overlap-end event has occurred with item specified via <<uid>>	
<<userProp>>	"b":<<uid>>		bounce (i.e., collision) event has occurred with item specified via <<uid>>	
<<userProp>>	"r2":{<<reqInfo>>(,<<reqInfo>>)*}		information returned to application software along with overlap-start, overlap-end, or bounce event, as requested via the "r2" or "r2+" <<ovrOpt>>	
<<userProp>>	"+<<propName>>":"<<number>>"		animation is stopped for property <<propName>> due to reaching the "min" or "max" <<aniOpt>> value; <<number>> indicates terminating velocity	
-	-	-	-	-
below this line are widget-specific properties and detailed syntax/description expanding on terms above this line				
-	-	-	-	-
### Label Name	### Grammar	### Shorthand	### Description	### Example
<<interactProp>>	"input":0|1	"in":0|1	interactive/input flag to signify whether user-input is disabled or enabled; item classes that can be interactive include all items whose value is <<boolean>> ("btn", "opt", "hold"), whose value is <<number>> ("num", "dt", "time"), and whose value is <<text>> ("txt", "rgb", "math", "doc"); "in":0 (default for <<itemClass>> "num", "dt", "time", "txt", "math", "rgb", "doc") signifies input is disabled, and "in":1 (default for <<itemClass>> "btn", "hold", "opt") signifies input is enabled; enabling user input means that the user can toggle item value (<<property>> "v"), and when user updates item value, UI software will send a UI->APP message that would look as such: {"t":<<ums>>,"u":<<uid>>,"v":<<value>>}; <<itemClass>> "txt" must include a newline in the value to enable multi-line input (e.g. [{"id":"name","v":"","in":1},{"id":"story","v":"\n","in":1}] creates a single-line text input field called "name" and a multi-line one called "story"); WARNING: when building computational agents to interact with UINL apps, never try to interact with disabled controls, because application code is not be expecting any interactions from those controls, and such interactions may be ignored or may cause unexpected behavior	Ex: APP->UI message {"A":[{"id":"type something","v":"","in":1},{"id":"button 1","v":false,"in":0}]} will add a text input box titled "type something" and a disabled button "button 1" to display, sending UI->APP message {"t":<<ums>>,"u":"type something","v":<<text>>} whenever user is done typing their input into the text input box
<<interactProp>>	"input":-1	"in":-1	disable input/interaction for all items in current container or frame; only for <<container>> components "bin", "win", "grid", "one", and <<url>> components "url" and "media"; setting "in":-1 for a container effectively disables all buttons/inputs and media interaction for all descendant items in said container; WARNING: when building computational agents to interact with UINL apps, never try to interact with disabled controls, because application code is not be expecting any interactions from those controls, and such interactions may be ignored or may cause unexpected behavior	
<<interactProp>>	"goButton":1	"go":1	"Go" button functionality; "Go" action for text and numeric type inputs; if text or numeric item has enabled input, adding "go":1 <<interactProp>> for this item will add a button (usually displayed in GUI as right-arrow icon or "Go" button) next to the input, and (1) would send UI->APP message with item value whenever user clicks this button, and (2) would disable the default behavior of sending UI->APP messages with item value whenever this input loses focus	Ex: APP->UI message {"A":[{"id":"Search","v":"","in":1,"go":1}]} will add a "Search" input field to display, such that if user types "abc" in this field and clicks/tabs elsewhere on display no UI->APP message is sent, but if user types "abc" and clicks "Go" button or hits the Enter key, UI->APP message {"t":<<ums>>,"u":"Search","v":"abc"} is sent
<<interactProp>>	"focus":1|0	"fcs":1|0	input focus; "fcs":1 puts focus on current item (if possible) and removes focus from any other item; "fcs":0 removes focus from current item	
<<interactProp>>	"keyShortcuts":[<<keyShortcut>>(,<<keyShortcut>>)*]	"keys":[<<keyShortcut>>(,<<keyShortcut>>)*]	keyboard shortcuts assigned to an item; if this item is an interactive (not disabled) <<boolean>> (i.e., button, select), keyboard shortcut toggles the item value (i.e., button is pressed, or item is selected) --- otherwise, if this item has a "fold" control, keyboard shortcut toggles item fold state (folds or unfolds it) --- otherwise, if this item is interactive ("in":1), keyboard shortcut will toggle item focus ("fcs" property changed to 1 if it's 0, or to 0 if it's 1)	
<<interactProp>>	"onContext":<<contextMenu>>	"onctx":<<contextMenu>>	context menu event listener and action; <<contextMenu>> describes an item with <<itemClass>> "ctx" to be added to display (in root container) whenever this item is right-clicked (or long-tapped or some other method provided by current system to bring up context menu); the context menu is drawn hovering above other content, aligned to current item (usually at location of pointer), and is automatically deleted from display when this item loses focus or when one of its inputs is edited or toggled; every item inside a "ctx" container is a button (i.e., "Class":"btn") by default (use "defaults" property for alternate behavior); in addition to <<contextMenu>> being added to display, UI->APP message {"t":<<ums>>,"u":<<uid>>,"ctx":[<<xy>>?]} will be sent; this <<contextMenu>> will also be displayed whenever the APP->UI message simulates a context-menu event for this item via a "ctx":[<<xy>>?] command; "onContext":<<contextMenu>> behavior can also be accomplished with <<interactProp>> "on":["ctx"] with an additional trigger setup {"!trigger":{"u":<<uid>>,"ctx":{}},"~add":[<<contextMenu>>]}	Ex: {"onctx":{"c":"ctx","v":[{"id":"Copy"},{"id":"Paste"}]}} will tell the UI software that when any item is right-clicked (1) a context menu should come up with clickable items "Copy" and "Paste", and (2) a UI->APP message {"t":<<ums>>,"ctx":[]} should be sent (and the app can also force this context menu to come up via a follow-up {"ctx":[]} command)
<<interactProp>>	"onEvent":{<<event>>:<<prec>>(,<<event>>:<<prec>>)*}	"on":{<<event>>:<<prec>>(,<<event>>:<<prec>>)*}	state-change event listeners; only triggered when <<event>> state-change is due to user action or user-software (i.e., not when the change is due to APP->UI message, scheduling command, or animation); <<prec>> declares a precision/filter for captured events (use <<prec>> [] to capture all events of the corresponding type; see <<prec>> definition for more detail)	Ex: APP->UI message {"on":{"wh":[]}} will add event-listeners for resize event to user display, and will send display width/height to application software whenever user resizes window or changes their display resolution in the format {"t":<<ums>>,"wh":[<<number>>,<<number>>]}; Ex: APP->UI message {"on":{"p":[],"sx":[],"sy":[],"k":["ArrowLeft","ArrowRight"]}} will add event-listeners for pointer/mouse movement, scroll, and keydown events to user display, and will send keydown keys to application software whenever ArrowLeft/ArrowRight are pressed in the format {"t":<<ums>>,"k":"ArrowLeft"} {"t":<<ums>>,"k":"ArrowRight"}, or mouse coordinates to application software every time a pointer/mouse moves in the format {"t":<<ums>>,"p":[<<number>>,<<number>>]}, or scroll events in the formats {"t":<<ums>>,"sx":<<number>>} or {"t":<<ums>>,"sy":<<number>>} whenever the display root container scrolls horizontally/vertically, or some combination of these if events occur within the same frame of time (e.g. {"t":<<ums>>,"p":[<<number>>,<<number>>],"sy":<<number>>})
<<interactProp>>	"onEvent":[<<event>>(,<<event>>)*]	"on":[<<event>>(,<<event>>)*]	state-change event listeners; only triggered when <<event>> state-change is due to user action or user-software (i.e., not when the change is due to APP->UI message, scheduling command, or animation)	Ex: APP->UI message {"on":["wh"]} will add event-listener for resize events to user display, and will send display width/height to application software whenever user resizes window or changes their display resolution in the format {"t":<<ums>>,"wh":[<<number>>,<<number>>]}; Ex: APP->UI message {"on":["p","sx","sy","k"]} will add event-listeners for pointer/mouse movement, scroll, and keydown events to user display, and will send keydown keys to application software whenever any keys are pressed in the format {"t":<<ums>>,"k":<<key>>}, or mouse coordinates to application software every time a pointer/mouse moves in the format {"t":<<ums>>,"p":[<<number>>,<<number>>]}, or scroll events in the formats {"t":<<ums>>,"sx":<<number>>} or {"t":<<ums>>,"sy":<<number>>} whenever the display root container scrolls horizontally/vertically, or some combination of these if events occur within the same frame of time (e.g. {"t":<<ums>>,"p":[<<number>>,<<number>>],"sy":<<number>>})
<<interactProp>>	"eventLeaf":[<<event>>(,<<event>>)*]	"leaf":[<<event>>(,<<event>>)*]	event option for container items signifying that any <<event>> that occurs inside a descendant of this container should be attributed to that descendant via <<userProp>> "ul"	Ex: {"A":[{"id":"my container","v":[{"id":"my text","v":"hello world"}],"on":{"pc":[]},"leaf":["pc"]}]} adds a container "my container" to display, and when the text "hello world" is clicked, UI->APP message {"t":<<ums>>,"u":"my container","ul":"my text","pc":[<<xy>>]} is sent
<<interactProp>>	"throttle":{<<event>>:<<uint>>(,<<event>>:<<uint>>)*}	"throt":{<<event>>:<<uint>>(,<<event>>:<<uint>>)*}	throttle event processing; specifies minimum timeout between same event triggers (in milliseconds)	Ex: {"on":{"p":[]},"throt":{"p":50}} will send pointer-device coordinates no more often than every 50ms (i.e. max 20 messages per second)
<<interactProp>>	"closeable":1	"cls":1	close functionality; enable user to close (i.e., remove from display) current container (e.g., has a button, usually ❌, that closes current container when clicked); works for any container except root container; when item is closed, UI->APP message will be sent {"t":<<ums>>,"u":<<uid>>,"v":null}, where <<uid>> refers to this container	Ex: APP->UI message {"A":[{"c":"win","id":"This is a popup!","cls":1}]} will display a popup titled "This is a popup!", the popup will have a button to close it, and when user presses that button, popup will disappear and a UI->APP message will be sent {"t":<<ums>>,"u":"This is a popup!","v":null}
<<interactProp>>	"deletable":1	"del":1	delete functionality; enable user to delete (i.e., remove from display) current item (e.g., has a button like ❌ or 🗑, that deletes current item when clicked); works for any item that is not a container; when item is deleted, UI->APP message will be sent {"t":<<ums>>,"u":<<uid>>,"v":null}	
<<interactProp>>	"reorderable":1	"ro":1	re-order functionality; enable user to reorder items in current container; when user is done reordering a given item, UI->APP message {"t":<<ums>>,"u":<<uid>>,"i":<<uint>>} is sent	
<<interactProp>>	"movable":[<<uid>>(,<<uid>>)*]	"mv":[<<uid>>(,<<uid>>)*]	enable user to be able to move (e.g. drag and drop) current item into another container; when user is done moving a given item, UI->APP message {"t":<<ums>>,"u":<<uid>>,"m":<<uid>>} is sent; when item is moved, it becomes the last item in target container (see <<interactProp>> "ro":1 for alternate behavior)	
<<interactProp>>	"movableDeep":[<<uid>>(,<<uid>>)*]	"mv\*":[<<uid>>(,<<uid>>)*]	enable user to be able to move (e.g. drag and drop) current item into another container, or into any of its descendant containers; when user is done moving a given item, UI->APP message {"t":<<ums>>,"u":<<uid>>,"m":<<uid>>} is sent; when item is moved, it becomes the last item in target container (see <<interactProp>> "ro":1 for alternate behavior)	
<<interactProp>>	"hash":[<<hashType>>,<<text>>]		hash text input prior to sending (useful to add a layer of security, *NOT* to replace server-side hashing); <<text>> is appended (i.e., added at the end) to item text before hashing (i.e., salt before hashing)	Ex: {"v":[{"id":"Password","v":"","in":1,"tag":"private","hash":["sha256","salty"]}]} would add a Password field to display, where the password is only ever sent to application software after being salted with "salty", and then hashed with sha256 hashing algorithm -- e.g., if user typed in "password" for password, the UI->APP message would be {"u":"Password","v":"29d6afd14bbcdf0b43d1f2c4fd8ecbe8bdedd5ee255e5fa530a3fb968cbbfa1a","t":<<ums>>}
<<interactProp>>	"encrypt":[<<encryption>>,<<text>>]	"enc":[<<encryption>>,<<text>>]	encrypt input value prior to sending (useful to add a layer of security); <<text>> is the encryption key	
<<containerProp>>	"defaults":<<qUpdate>>	"df":<<qUpdate>>	default template for descendant element creation; "df" is processed *before* "v" property; a child container can override some or all default properties with its own "df" specification (note: df inheritance is *shallow*, such that a container that is overriding any part of a property's default value overrides the entire default value for that property); default template cannot include "id"; if a default template includes item value, the value can never be an array (for safety reasons, to prevent infinite loops); defaults are never applied when such application might be illegal (e.g., {"A":[{"c":"grid","df":{"c":"num"}}]} adds a grid to display whose cell class types will be "num" by default, but grid rows will still be of class type "bin" because only "bin" items are allowed as children of "grid"); if default template includes "c", it is only applied to children whose "v" property isn't declared, or is compatible (e.g. class "opt" is only compatible with boolean values, so {"df":{"c":"opt"},"v":["hello","world",{"id":"a"},{"id":"b","v":false}]} will add two text items, "hello" and "world", and two selectable options "a" and "b"); if default template includes "v", it is only applied to children whose "c" property isn't declared, or is compatible (e.g. class "opt" is only compatible with boolean values, so {"df":{"v":true},"v":[{"id":"a","c":"opt"},{"id":"b","c":"num"}]} will add a selectable option item "a" with a value of true, and a numeric item "b" with a default numeric value (0))	Ex: APP->UI message {"df":{"step":1}} will ensure all new numeric items are integers by default; Ex: APP->UI message {"v":[],"Q":[{"df":{"tag":["tagA"]},"A":["a","b"]},{"df":{"tag":["tagB"]},"A":["c","d"]}]} will create the following UIOM: {"df":{"tag":["tagB"]},"v":[{"c":"txt","v":"a","tag":["tagA"]},{"c":"txt","v":"b","tag":["tagA"]},{"c":"txt","v":"c","tag":["tagB"]},{"c":"txt","v":"d","tag":["tagB"]}]}
<<binProp>>	"foldable":0|1|2	"fold":0|1|2	container is foldable/minimizable; ignored by root container; "fold":0 (default) is the absence of any fold control, "fold":1 means that item is fully visible, but has a fold control (i.e. a button that minimizes the item), and "fold":2 means that item is folded (i.e. minimized) and has a control that would unfold it; UI->APP message {"t":<<ums>>,"u":<<uid>>,"fold":1} or {"t":<<ums>>,"u":<<uid>>,"fold":2} is sent when container is folded/unfolded; avoid marking items foldable as an arbitrary style choice -- rather, mark an item as folded/foldable to signify reduced prominence of this item's content (as compared to items that are always in full view); WARNING: when building computational agents to interact with UINL apps, treat "fold":2 containers as if they had all their controls disabled, because application code may not be expecting any interactions from controls in a folded container	
<<binProp>>	"size":[<<xy>>]	"wh":[<<xy>>]	size of container; <<xy>> specifies this container's width and height; do not use this option for aesthetics, only when it is essential to task (e.g. for replay); this option is likely ignored by computational agents; there is no guarantee whether content inside current container is scaled when "wh" changes	
<<numProp>>	"min":<<number>>		minimum displayable value	
<<numProp>>	"max":<<number>>		maximum displayable value	
<<numProp>>	"step":<<number>>		step for current numeric value; <<number>> must be greater than zero; rounds displayable to nearest multiple of <<number>> (e.g., both {"v":1.75,"step":2} and {"v":2.15,"step":2} will be displayed as 2); if <<numProp>> "min" is present, valid values begin at "min" (e.g. {"c":"num","min":1,"step":2} is a numeric item that only displays odd positive integers), otherwise they begin at 0 and go in both directions (e.g., {"c":"num","step":2} is a numeric item that only displays even integers)	Ex: APP->UI message {"A":[{"id":"x","v":57.1,"step":0.01}]} should be interpreted/displayed as x=57.10, whereas {"A":[{"id":"x","v":57.1,"step":5}]} should be interpreted/displayed as x=55, and {"A":[{"id":"x","v":57.1,"step":5,"min":-1}]} should be interpreted/displayed as x=59
<<numProp>>	"unit":<<text>>		unit of measurement (e.g. "$", "%", "kg", "€ million", "$ k")	
<<numProp>>	"logScale":<<number>>	"log":<<number>>	current numeric value is in log-scale; <<number>> specifies the base of the scale; <<numProp>> "log" interacts with <<numProp>> "min" and <<numProp>> "step", such that the first exponent, X, is log base-"log" of "min", and each next value after "min" that is allowed for current item is "log" raised to X, where X is incremented by "step" until "log" raised to X exceeds <<numProp>> "max"; if <<numProp>> "log" is specified, but "step" or "min" are not, "step" and "min" are both assumed to be 1.0	Ex: APP->UI message {"A":[{"id":"x","in":1,"log":2}]} adds a numeric input to display whose values are allowed to be 1, 2, 4, 8, 16, 32, etc.; Ex: APP->UI message {"A":[{"id":"x","in":1,"log":10,"min":0.01,"max":1000}]} adds a numeric input to display whose values are allowed to be 0.01, 0.1, 1, 10, 100, and 1000; Ex: APP->UI message {"A":[{"id":"x","in":1,"log":10,"min":0.01,"max":10000,"step":2}]} adds a numeric input to display whose values are allowed to be 0.01, 1, 100, and 10000
<<txtProp>>	"length":<<uint>>	"len":<<uint>>	max number of characters; for "doc" components max number of characters includes markup	
<<txtProp>>	"markText":[<<number>>,<<number>>]	"mark":[<<number>>,<<number>>]	mark text region selection; <<number>>,<<number>> are start and end of region selection, respectively; each <<number>> must be an integer; when <<number>> is negative, characters are counted from end of string, where -1 is the end of text (i.e., "mark":[0,-1] selects entire text); WARNING: for "doc" components, the start/end of region selection includes markup in editable mode ("input":1) and does not include markup in non-editable mode ("input":0)	
<<txtProp>>	"format":<<format>>	"fmt":<<format>>	format type for "txt" and "doc" components; if certain markup format is required for "doc" components, or certain syntax highlighting is required for "txt" components, app software should check that UI software can handle these via the "!!require" directive (e.g. {"!!require":{"fmt":[".md",".csv"]}} ensures that markdown format is supported for "doc" components and that CSV syntax highlighting is supported for "txt" components)	Ex: APP->UI message {"A":[{"c":"doc","fmt":".md","v":"_this text is underlined_"}]} will add underlined text "this text is underlined" to display (interpreted as underlined because syntax was declared to be markdown via "fmt":".md" property); Ex: APP->UI message {"A":[{"fmt":".py","v":"print('hello')"}]} would add a text item to display with the text "print('hello')", and inform UI software that this text is python code, potentially enabling syntax highlighting, monospace fonts, and potentially other python code -specific options
<<fileProp>>	"accepts":"bin"		single file selection, binary format assumed; "accepts":"bin" (default) means that UI software will convert file contents to base64 before sending this content via UI->APP message	
<<fileProp>>	"accepts":"text"		single file selection, text format assumed; "accepts":"text" means that UI software will NOT change file contents before sending to App software via a UI->APP message (WARNING: this may result in loss of data or error if the file is in binary format)	
<<fileProp>>	"accepts":<<uint>>		single or multiple file selection, file(s) added to a zip archive before sending to app software; "accepts":1 means that this file chooser only allows selecting a single file; "accepts":<<uint>> where <<uint>> is greater than 1 enables choosing more than one file; selected files are added to a zip archive, and the zip archive content is converted to base64 before sending this content via UI->APP message; use this option if you want to preserve original file name(s) (zip archive includes original file names)	
<<fileProp>>	"format":<<fileTypes>>	"fmt":<<fileTypes>>	specify which file formats are allowed for user file selection (e.g., "fmt":".jpg,.jpeg,.png" allows JPEG and PNG file selection)	
<<optProp>>	"optionGroup":<<text>>	"grp":<<text>>	option group; if this property is present (not null), the "opt" item belongs to a group (named via <<text>>) where only one item can be selected at a time (e.g. radio-buttons, where selecting one button deselects previously selected item in the same group); when a new item in group is selected, a previously selected item in this group is automatically deselected (setting its value to false), but does *NOT* send a UI->APP {..."v":false...} message (i.e., its deselection will be presumed by app software because it's in the same "grp" as the newly selected item)	Ex: {"v":[{"id":"Choose a car","df":{"c":"opt","grp":"car"},"v":[{"id":"Subaru"},{"id":"Tesla"}]}]} creates a container "Choose a car" with two radio buttons -- "Subaru" and "Tesla" where only one can be chosen at a time
<<holdProp>>	"holdGroup":<<text>>	"hgrp":<<text>>	hold-button group; if this property is present (not null), the "hold" item belongs to a group (named via <<text>>) where, once one of the "hold" buttons is pressed down, moving pointer/mouse over another "hold" item in the same group (without stopping the press-down action) will automatically press down (set value to true) that item; when a new holddown button is selected in this way, the previously selected button will be automatically deselected, but may *NOT* send a UI->APP {..."v":false...} message (i.e., its deselection will be presumed by app software because it's in the same "hgrp" as the newly selected item)	Ex: APP->UI message {"v":[{"c":"hold","hgrp":"nav","id":"West"},{"c":"hold","hgrp":"nav","id":"East"}]} will add West and East holddown buttons to display, and if user moves mouse over East and presses down the mouse button, East will be selected and UI->APP message {"t":<<ums>>,"u":"East","v":true} will be sent, and then if user moves the mouse over the West button without letting go of mouse button, West will be selected and UI->APP message {"t":<<ums>>,"u":"West","v":true} will be sent (UI->APP message {"t":<<ums>>,"u":"East","v":false} is not sent -- it is presumed)
<<ctxProp>>	"reference":<<uid>>	"ref":<<uid>>	placement of context menu; when this option is present and not null, this context menu and is drawn aligned to (or somehow pointing to) the location of the item indicated by <<uid>> (usually at the location of the pointer); when this option is absent (or null), UI software will take its best guess as to where to draw this context menu (usually aligned to the last focused item, likely at last location of the pointer action)	Ex: {"A":[{"id":"my text","v":"hello world"},{"id":"copy-paste","c":"ctx","ref":"my text","v":[{"id":"Copy"},{"id":"Paste"}]}]} adds the text "hello world" to display, as well as a context menu drawn aligned to the "hello world" text
<<ctxProp>>	"location":[<<xy>>]	"xy":<<xy>>	coordinate location of context menu; when this option is present and not null, this context menu and is drawn aligned to (or somehow stemming from) the <<xy>> coordinates within the "reference" item; when this option is absent (or null), UI software will take its best guess as to where to draw this context menu (likely at last location of the pointer action)	
<<winProp>>	"modal":1	"mod":1	window modality; "mod":1 makes window modal -- prevents interactions with all sibling items that are lower in the stack-order (i.e., have lower index property "i"), and setting "mod" to null or removing this window will re-enable interactions	
<<winProp>>	"location":[<<xy>>]	"xy":[<<xy>>]	location of "win" item's top-left corner relative to its parent top-left corner; do not use this option for aesthetics, only when it is essential to task (e.g. for replay)	
<<gridProp>>	"headerRow":1	"head":1	header row; this flag indicates that the first row of the current grid is a header row, which has special functionality -- the caption for header row is the header for the first grid column (the grid column which contains all the other row captions, see "Employee ID" example below), and header row cells are tied to their respective columns in terms of (1) placement (when index for a cell in header row is changed by setting property "i":<<uint>> for that cell or via "ro":1 functionality, the entire column is moved, not just that one cell), (2) deletion (when cell in header row is deleted via "v":null or via "cls":1 functionality, the entire column is deleted, not just that one cell), (3) folding ("fold" functionality for a cell in header row will actually fold/unfold the entire column, not just that one cell), (4) defaults (setting property "df" for a cell in header row will set defaults for all cells in the entire column), and (5) potentially other properties (e.g., setting properties "tag", "ef", and "af" for a cell in header row may apply visual effects to the entire column, not just that cell); "head" property is processed after "df", but before "v", "A", "rows", and "cols" properties	Ex: APP->UI message {"c":"grid","id":"personnel","head":1,"v":[{"cap":"Employee ID","ro":1,"v":[{"id":"Name"},{"id":"Age"},{"id":"Gender"},{"id":"Wage","df":{"unit":"$","step":0.01}}]},{"id":"0001","v":["mary",28,"f",35.5]},{"id":"0002","v":["john",39,"m",32]}]} creates a table where the first row contains column headers "Employee ID", "Name", "Age", "Gender", and "Wage", and all values in the "Wage" column have {"unit":"$","step":0.01} defaults, and the column can be re-ordered by the user
<<gridProp>>	"rows":<<uint>>		minimum number of rows for current grid; any blank cells created due to this property specification will be initialized with a "bin" item	
<<gridProp>>	"columns":<<uint>>	"cols":<<uint>>	minimum number of columns for current grid; any blank cells created due to this property specification will be initialized with a "bin" item	
<<gridProp>>	"hexGrid":1|2	"hex":1|2	offset every other row in the grid, such that each non-peripheral cell has 6 adjacent cells (left, right, above-left, above-right, below-left, below-right) rather than 4 (left, right, above, below); "hex":1 means that even rows are pushed over half a cell-width to the right (such that leftmost cell in the top row is above and to the left of leftmost cell in the second row), and "hex":2 means that even rows are pushed over half a cell-width to the left (such that leftmost cell in top row is above and to the right of leftmost cell in the second row, and shares borders with both first and second cells in the second row)	
<<mediaProp>>	"format":<<format>>	"fmt":<<format>>	format type for "media" components; if certain media types are required for "media" components, app software should check that UI software can handle these via the "!!require" directive (e.g. {"!!require":{"fmt":[".mp3","youtube.com",".md"]}} ensures mp3's and youtube videos can be embedded and controlled as "media" components, and that markdown syntax is supported for "doc" components)	Ex: APP->UI message {"A":[{"c":"media","v":"mysong.mp3","fmt":".mp3"}]} would add an embedded media player for MP3 file "mysong.mp3" to the display
<<mediaProp>>	"play":1|0		audio/video time playback; "play":0 (default) indicates media is paused, "play":1 indicates it is playing	
<<mediaProp>>	"at":<<number>>		audio/video time position (in seconds)	
<<plotProp>>	"axisx":{(<<axisOpt>>(,<<axisOpt>>)*)?}		x-axis label/markers; if any <<axisOpt>> is missing, UI software will automatically generate axis markers based on data-points	
<<plotProp>>	"axisy":{(<<axisOpt>>(,<<axisOpt>>)*)?}		y-axis label/markers; if any <<axisOpt>> is missing, UI software will automatically generate axis markers based on data-points	
<<dataProp>>	"plotType":<<plotType>>	"plt":<<plotType>>	plot type for current data series	
<<dataProp>>	"axisx":{(<<axisOpt>>(,<<axisOpt>>)*)?}		x-axis label/markers; this property is ignored if this "data" item is a child of "plot"	
<<dataProp>>	"axisy":{(<<axisOpt>>(,<<axisOpt>>)*)?}		y-axis label/markers; this property is ignored if this "data" item is a child of "plot"	
<<dpProp>>	"value":<<number>>	"v":<<number>>	data-point value (height for column plots, y-value for line/xy/box/ohlc plots); for <<plotType>> "ohlc" this indicates closing price	
<<dpProp>>	"x":<<number>>		data-point x-value; if this property is not specified, x-value is assumed to be this data-point's respective tic on the x-axis	
<<dpProp>>	"errorBars":<<number>>	"err":<<number>>	error bars lengths (i.e., how far error bars extend from "v"); for <<plotType>> "box", "v" is the mid-point of the box (usually used to represent mean or median), and "err" is half the height of the box	
<<dpProp>>	"errorBars":[<<number>>,<<number>>]	"err":[<<number>>,<<number>>]	error bars lengths; <<number>>,<<number>> represent top and bottom error bars lengths, respectively (i.e., how far error bars extend up and down from "v"); for <<plotType>> "ohlc" <<number>>,<<number>> represent how far above the closing price the high was and how far below closing the low price was, respectively; for <<plotType>> "box", "v" is the mid-point of the box (usually used to represent mean or median), and <<number>>,<<number>> indicate how far above the mid-point and how far below the mid-point the top and bottom edges of box are drawn, respectively (usually used to represent margins of error)	
<<dpProp>>	"errorBars":[<<number>>,<<number>>,<<number>>,<<number>>]	"err":[<<number>>,<<number>>,<<number>>,<<number>>]	error bars lengths for <<plotType>> "box", turning it into a box-and-whiskers plot; "v" is the mid-point of the box (usually used to represent median), and <<number>>,<<number>>,<<number>>,<<number>> indicate how far above the mid-point the top edge of the box is drawn, how far below the mid-point the bottom edges of box is drawn, how far above mid-point the top whisker is drawn, and how far below mid-point the bottom whisker is drawn, respectively (usually used to represent upper quartile, lower quartile, maximum, and minimum, respectively); for any <<plotType>> other than "box", the 3rd and 4th <<number>>'s are ignored	
<<dpProp>>	"affect":<<number>>	"af":<<number>>	same as <<property>> "af" for all other item classes, except for <<plotType>> "ohlc"; for <<plotType>> "ohlc" <<number>> can be any number, and this property indicates price change, and it is used to calculate/plot opening price	Ex: {"c":"data","plt":"ohlc","v":[100,120,110,130],"<-":{"af":[5,18,-10,22]}} will plot open-close values of 95-100, 102-120, 120-110, and 108-130
<<dpProp>>	"effect":<<number>>	"ef":<<number>>	same as <<property>> "ef" for all other item classes, except for <<plotType>> "xy"; for <<plotType>> "xy" <<number>> should always be between 0 and 1, and will be displayed as the size of the drawn point	
<<viewportProp>>	"width":<<uint>>	"w":<<uint>>	width of viewport	
<<viewportProp>>	"height":<<uint>>	"h":<<uint>>	height of viewport	
<<grgProp>>	"scaleX":<<number>>	"x^":<<number>>	scale (stretch/zoom) group of items along x-axis ("x" is the origin); <<number>> should be higher than 0 and indicates percent of scale (i.e., "x^":100 is original scale)	
<<grgProp>>	"scaleY":<<number>>	"y^":<<number>>	scale (stretch/zoom) group of items along y-axis ("y" is the origin); <<number>> should be higher than 0 and indicates percent of scale (i.e., "y^":100 is original scale)	
<<grgProp>>	"scaleZ":<<number>>	"z^":<<number>>	scale (stretch/zoom) group of items along z-axis inside a "3d" viewport ("z" is the origin); <<number>> should be higher than 0 and indicates percent of scale (i.e., "z^":100 is original scale)	
<<grgProp>>	<<2dProp>>|<<3dProp>>		translate/rotate and overlap (collision) event specifications for a group of items; <<3dProp>>'s apply only to items inside "3d" containers, whereas <<2dProp>>'s apply to items in both "2d" and "3d" containers	
<<grProp>>	"shape":<<shape>>	"shp":<<shape>>	item shape; if no shape is specified, item shape does not matter; do not use "shp" for aesthetics, only when shape specification is functionally relevant -- use "tag" and "!style" properties for all aesthetic choice specifications	
<<grProp>>	"width":<<number>>	"w":<<number>>	width of the item; default is 1	
<<grProp>>	"height":<<number>>	"h":<<number>>	height of the item; default is 1	
<<grProp>>	"depth":<<number>>	"d":<<number>>	depth of the item (only for "gr" items inside "3d" containers); default is 1	
<<grProp>>	<<2dProp>>|<<3dProp>>		location, rotation, and overlap (collision) event specifications for a graphical item; <<3dProp>>'s apply only to items inside "3d" containers, whereas <<2dProp>>'s apply to items in both "2d" and "3d" containers	
<<grProp>>	"opaque":1|0	"opq":1|0	set item as opaque or transparent; "opq":1 ensures this item is opaque (such that any siblings behind it are obstructed); "opq":0 ensures that this item background is transparent (though the item should still be visible in some way, e.g., item border may be visible); "opq":0 items that do not themselves capture pointer events allow pass-through of pointer events to any items behind them, whereas "opq":1 items do not ever allow pass-through of pointer events to any items behind them; if "opq" property is not set (i.e., "opq":null), this indicates to UI software that opaqueness of the item does not matter, though the item should still capture pointer events	
<<lProp>>	"value":<<uid>>	"v":<<uid>>	link target item; this is a partial <<uid>> of another item within this network graph -- it specifies a unique path to another item within this item's root network graph container (root network graph container is the "ng" item that is the ancestor of this item whose parent is not also "ng")	Ex: APP->UI message {"A":[{"c":"2d","w":140,"h":140,"df":{"w":20,"h":20},"v":[{"id":"A","x":20,"y":20,"v":["D","E"]},{"id":"B","x":20,"y":60,"v":[{"v":"F","ef":0.1}]},{"id":"C","x":20,"y":100,"v":[{"v":"D","ef":0.5}]},{"id":"D","x":100,"y":20},{"id":"E","x":100,"y":60},{"id":"F","x":100,"y":100}]} would add a 2d container to display with a network graph with nodes A, B, C on the left and D, E, F on the right and weighted links where the weights are 0, 0, 0.1, and 0.5 for links A-D, A-E, B-F, and C-D, respectively
<<lProp>>	"direction":(-1)|0|1	"dir":(-1)|0|1	link direction; 0 (default) is a non-directional link, 1 signifies direction from parent item to the target item (i.e., item specified as via the "v" property of this link), and -1 specifies that the direction is reversed, going from target item to this link's parent item	
<<animation>>	"frameset":[<<qUpdate>>(,<<qUpdate>>)*]	"fs":[<<qUpdate>>(,<<qUpdate>>)*]	frames of updates for current item, each of which can be executed by manipulating "f" and "±f" <<animation>> properties; zero-indexed; do not use "frames" for sprite animation if its purpose is decorative, rather than functional (the rule of thumb is -- if you wouldn't put it in the API, do not put it in UINL outside of the "!style" <<uiDirective>>)	Ex: APP->UI message {"A":[{"id":"my text","v":"","frames":[{"v":"hello"},{"v":"world"}]}]} adds a blank text item called "my text" to display, and a follow-up APP->UI message {"U":"my text","f":0} would change its value to "hello", and a follow-up APP->UI message {"U":"my text","f":1} would change its value to "world"
<<animation>>	"frame":<<number>>	"f":<<number>>	frame to execute; <<number>> indicates index of frame to execute (i.e., change item properties in accordance with the frame whose index the "frames" <<animation>> list is closest to <<number>>); if <<number>> does not match an existing frame index (i.e., if the number is not an integer, or it's less than 0, or it's higher than the number of existing frames), the frame whose index is closest to <<number>> is executed	Ex: APP->UI message {"A":[{"id":"my text","v":"","frames":[{"v":"hello"},{"v":"world"}]}]} adds a blank text item called "my text" to display, and a follow-up APP->UI message {"U":"my text","f":0} would change its value to "hello", and a follow-up APP->UI message {"U":"my text","f":1} would change its value to "world"
<<animation>>	<<animationVelocity>>:<<number>>		animation for a numeric property; <<number>> indicates current velocity (rate of change per second); if the numeric property that is being animated is not set at the time animation is initiated, initial value starts at 0.0; when animation stops (whether due to reaching its target value or due to a collision), <<animationVelocity>> is set to the text string "<<number>>", where <<number>> is the terminal velocity	Ex: APP->UI message {"A":[{"c":"time","id":"Time Left","v":30,"+v":-1,"min":0}]} will add a time item called "Time Left" to display, and animate its value from 30s down to 0s at a rate of 1 per second, and will send a UI->APP message {"t":<<ums>>,"u":"Time Left","+v":"-1"} once animation stops
<<animation>>	<<animationVelocity>>:<<text>>		animation for corresponding property is stopped	
<<animation>>	<<animationOptions>>:{<<aniOpt>>(,<<aniOpt>>)*}		animation options for a numeric property	Ex: APP->UI message {"A":[{"c":"time","id":"Time Left","v":30,"+v":-1,">v":{"step":0.5,"min":0}}]} will add a time item called "Time Left" to display, and animate its value from 30s down to 0s at a rate of 1 per second, updating every 0.5 seconds, and will send a UI->APP message {"t":<<ums>>,"u":"Time Left","+v":"-1"} once animation stops
-	-	-	-	-
everything below is detailed syntax/description expanding on terms above this line				
-	-	-	-	-
### Label Name	### Grammar	### Shorthand	### Description	### Example
<<userPropTrigger>>	<<userProp>>		exact match trigger for current update; current update/declaration is triggered whenever UI->APP message matches the specified <<userProp>>'s	Ex: {"Tr":{"u":"Submit","v":true},"in":-1} will disable all display interactions whenever the "Submit" button is clicked (useful to prevent accidental repeat-clicks in asynchronous tasks)
<<userPropTrigger>>	<<userPropName>>:{}		wildcard trigger for current update; current update/declaration is triggered whenever UI->APP message includes <<userPropName>>, regardless of its corresponding value	Ex: {"~add":[{"c":"opt","id":"myOption"}],"Q":[{"Tr":{"u":"myOption","v":{}},"~add":["option clicked"]}]} will add a selectable option "myOption" to display, and then add the text "option clicked" whenever myOption is toggled on or off
<<url>>	*** legal url ***			
<<req>>	<<propName>>		request property value for current item	
<<req>>	"(xy)|(wh)|(whc)"		request calculated location (xy), size of viewport (wh), and size of content (whc)	
<<reqInfo>>	<<property>>|<<calcProp>>		item property value	
<<calcProp>>	"xy":[<<xy>>]		calculated distance of item's top-left corner from its parent's top-left corner	
<<calcProp>>	"wh":[<<xy>>]		calculated item size	
<<calcProp>>	"whc":[<<xy>>]		calculated size of item content	
<<xy>>	<<number>>,<<number>>		location or size; <<number>>,<<number>> represent location/size on horizontal and vertical axes, respectively	
<<matchByVal>>	<<propName>>:<<value>>		match property	Ex: {"U**":{"v":1},"v":0} would set all 1's to 0's throughout the display
<<matchByVal>>	<<propName>>:<<values>>		match property array values or associative array keys; all specified <<value>>'s must be found in item property array or associative array for property to match	Ex: {"U**":{"on":["pc"]},"on":{"pc":null}} will find all items in display that subscribe to pointer-click events, and unsubscribe them from this event
<<value>>	{}		wildcard non-null value; only for <<Command>>'s "U*":, "U**", "Tr", and <<uiDirective>> "task" -- use {} instead of <<value>> to match any non-null value in <<matchByVal>> and <<userProp>>	Ex: APP->UI message {"U**":{"tag":{}},"tag":null} will annul all "tag" properties in the display; Ex: APP->UI message {"on":{"wh":[]}} will add a "wh" event-listener to app window and a follow-up message {"Tr":{"u":null,"wh":{}},"A":["resized!"]} will add text "resized!" to display whenever user resizes their app window
<<tag>>	<<text>>		custom tags; visually-distinct styles for each such <<tag>> *must* be provided via the "!style" <<uiDirective>> for human-facing UI software	
<<captionText>>	<<text>>		caption text is standard <<text>> with one exception -- it may include inline images (icons) indicated via the following escape sequence: ![<<altTxt>>](<<url>>), where <<altTxt>> is optional text to display if the <<url>> resource is not loading (if no <<altTxt>> is specified and there is an error loading the image, nothing is shown)	Ex: {"A":[{"id":"uploadBtn","c":"btn","cap":"![Upload](/images/upload.png)"}]} will add a button to display with caption displaying /images/upload.png icon, and if this icon cannot be loaded, the text "Upload" will be displayed instead; Ex: {"A":[{"id":"saveBtn","c":"btn","cap":"Save ![](/images/save.png)"}]} will add a button to display with caption displaying the text "Save " followed by /images/save.png icon, and if the save.png icon cannot load, the caption will just display the "Save " text
<<contextMenu>>	<<container>>|<<pList>>		container item that would appear at location of context action hovering above other content; this container's Class will always be "ctx"
<<event>>	*** name of event: the part to the left of the colon in the <<eventInfo>> expression (e.g. "k", "pc", "copy") ***			
<<eventInfo>>	<<calcProp>>		location and size -change events	
<<eventInfo>>	"v":<<value>>		on-value-change event listener; useful for dynamic input fields (e.g., dynamic search-boxes)	
<<eventInfo>>	"fold":1|2		minimize/restore event listener; user folded/minimized or unfolded/restored item	
<<eventInfo>>	"fcs":0|1		on-focus/on-blur event listener; user clicked or tabbed over onto current item or one of its descendants	
<<eventInfo>>	"sx":<<number>>		horizontal scrolling event listener; user changed horizontal scrolling position	
<<eventInfo>>	"sy":<<number>>		vertical scrolling event listener; user changed vertical scrolling position	
<<eventInfo>>	"mark":[<<uint>>,<<uint>>]		text-selection event listener; user selected text in current item	
<<eventInfo>>	"copy":<<text>>		text copied (in addition to standard clipboard copy, this should also capture when text is copied by dragging-dropping)	
<<eventInfo>>	"cut":<<text>>		text cut	
<<eventInfo>>	"paste":<<text>>		text pasted (in addition to standard clipboard paste, this should also capture when text is pasted by dragging-dropping)	
<<eventInfo>>	"k":<<key>>		keyboard key-down event	
<<eventInfo>>	"ku":<<key>>		keyboard key-up event	
<<eventInfo>>	"kc":<<keyCode>>		keyboard key-down event with key-code	
<<eventInfo>>	"kcu":<<keyCode>>		keyboard key-up event with key-code	
<<eventInfo>>	"sw":<<number>>		scroll wheel (or equivalent device) is swiped up or down; <<number>> represents the vertical scroll amount (up is negative, down is positive)	
<<eventInfo>>	"swh":<<number>>		horizontal scroll wheel (or equivalent device) is swiped left or right; <<number>> represents the horizontal scroll amount (left is negative, right is positive)	
<<eventInfo>>	"ctx":[<<xy>>?]		context menu event (right-click or long-tap or some other method provided by current system to bring up context menu); <<xy>> indicates the mouse/pointer location within current item, if available	
<<eventInfo>>	"pd":[<<xy>>]		pointer down (mouse primary button-down or tap-start event); <<xy>> is the mouse/pointer location within current item; this event does not repeat while button is held down	
<<eventInfo>>	"pu":[<<xy>>]		pointer up (mouse primary button-up or tap-end even)t; <<xy>> is the mouse/pointer location within current item	
<<eventInfo>>	"pc":[<<xy>>]		pointer click (mouse primary click or tap event); <<xy>> is the mouse/pointer location within current item	
<<eventInfo>>	"pcc":[<<xy>>]		pointer (or mouse primary button) double-click or double-tap event; <<xy>> is the mouse/pointer location within current item	
<<eventInfo>>	"md":[<<uint>>(,<<xy>>)?]		mouse/pointer button-down event for non-primary buttons; <<uint>> is the button number, and it is zero-indexed, such that "md":[1] signifies secondary mouse button, "md":[2] signifies third (auxiliary, usually scroll-wheel) button, "md":[3] signifies fourth button, "md":[4] signifies fifth mouse button, and "md":[0] is not a valid event (use "pd" event for primary mouse button capture); if mouse/pointer location is known, <<xy>> (location within current item) is sent; this event does not repeat while button is held down	
<<eventInfo>>	"mu":[<<uint>>(,<<xy>>)?]		mouse/pointer button-up event for non-primary buttons; <<uint>> is the button number, and it is zero-indexed, such that "mu":[1] signifies secondary mouse button, "mu":[2] signifies third (auxiliary, usually scroll-wheel) button, "mu":[3] signifies fourth button, "mu":[4] signifies fifth mouse button, and "mu":[0] is not a valid event (use "pu" event for primary mouse button capture); if mouse/pointer location is known, <<xy>> (location within current item) is sent	
<<eventInfo>>	"p":[<<xy>>]		pointer/mouse location-change event; <<xy>> is the mouse/pointer location within current item	
<<eventInfo>>	"pe":[<<xy>>]		pointer/mouse movement-end event; sent only when mouse/pointer stops moving for longer than 100ms (default) or whatever number of milliseconds is set via the "throt" <<interactProp>> for the "pe" event	
<<eventInfo>>	"po":[1|0(,<<xy>>)?]		pointer/mouse over and out events; pointer/mouse moved over ("po":[1,<<xy>>]) or out of ("po":[0,<<xy>>]) current item; location where pointer/mouse left item is only sent if available	
<<eventInfo>>	"pp":<<number>>		pointer pressure and hover distance; some pointer devices have pressure and/or hover sensitivity -- use the "pp" event to capture when pointer pressure or hover state changes; when pointer device is hovering -1 <= <<number>> < 0, where -1 is max hover detection range; when pointer device is touching 0 < <<number>> <= 1, where 1 is highest detectable pressure; "pp":0 is sent when pointer is no longer hovering or touching	
<<eventInfo>>	"p2d":[<<xy>>]		2nd pointer down (tap-start) event; <<xy>> is the pointer location within current item; this event does repeat while pointer is held down	
<<eventInfo>>	"p2u":[<<xy>>]		2nd pointer up (tap-end) event; <<xy>> is the pointer location within current item	
<<eventInfo>>	"p2c":[<<xy>>]		2nd pointer click (tap) event; <<xy>> is the pointer location within current item	
<<eventInfo>>	"p2cc":[<<xy>>]		2nd pointer double-click (double-tap) event; <<xy>> is the pointer location within current item	
<<eventInfo>>	"p2":[<<xy>>]		2nd pointer location-change event; <<xy>> is the pointer location within current item	
<<eventInfo>>	"p2e":[<<xy>>]		2nd pointer movement-end event; sent only when pointer stops moving for longer than 100ms (default) or whatever number of milliseconds is set via the "throt" <<interactProp>> for the "p2e" event	
<<eventInfo>>	"p2o":[1|0(,<<xy>>)?]		2nd pointer moved over ("p2o":[1,<<xy>>]) or out of ("p2o":[0,<<xy>>]) current item; location where pointer left item is only sent if available	
<<eventInfo>>	"p2p":<<number>>		2nd pointer pressure and hover distance; some pointer devices have pressure and/or hover sensitivity -- use the "pp" event to capture when pointer pressure or hover state changes; when pointer device is hovering -1 <= <<number>> < 0, where -1 is max hover detection range; when pointer device is touching 0 < <<number>> <= 1, where 1 is highest detectable pressure; "p2p":0 is sent when 2nd pointer is no longer hovering or touching	
<<eventInfo>>	"p3d":[<<xy>>]		3rd pointer down (tap-start) event; <<xy>> is the pointer location within current item; this event does repeat while pointer is held down	
<<eventInfo>>	"p3u":[<<xy>>]		3rd pointer up (tap-end) event; <<xy>> is the pointer location within current item	
<<eventInfo>>	"p3c":[<<xy>>]		3rd pointer click (tap) event; <<xy>> is the pointer location within current item	
<<eventInfo>>	"p3cc":[<<xy>>]		3rd pointer double-click (double-tap) event; <<xy>> is the pointer location within current item	
<<eventInfo>>	"p3":[<<xy>>]		3rd pointer location-change event; <<xy>> is the pointer location within current item	
<<eventInfo>>	"p3e":[<<xy>>]		3rd pointer movement-end event; sent only when pointer stops moving for longer than 100ms (default) or whatever number of milliseconds is set via the "throt" <<interactProp>> for the "p3e" event	
<<eventInfo>>	"p3o":[1|0(,<<xy>>)?]		3rd pointer moved over ("p3o":[1,<<xy>>]) or out of ("p3o":[0,<<xy>>]) current item; location where pointer left item is only sent if available	
<<eventInfo>>	"p3p":<<number>>		3rd pointer pressure and hover distance; some pointer devices have pressure and/or hover sensitivity -- use the "pp" event to capture when pointer pressure or hover state changes; when pointer device is hovering -1 <= <<number>> < 0, where -1 is max hover detection range; when pointer device is touching 0 < <<number>> <= 1, where 1 is highest detectable pressure; "p3p":0 is sent when 3rd pointer is no longer hovering or touching	
<<eventInfo>>	"p4d":[<<xy>>]		4th pointer down (tap-start) event; <<xy>> is the pointer location within current item; this event does repeat while pointer is held down	
<<eventInfo>>	"p4u":[<<xy>>]		4th pointer up (tap-end) event; <<xy>> is the pointer location within current item	
<<eventInfo>>	"p4c":[<<xy>>]		4th pointer click (tap) event; <<xy>> is the pointer location within current item	
<<eventInfo>>	"p4cc":[<<xy>>]		4th pointer double-click (double-tap) event; <<xy>> is the pointer location within current item	
<<eventInfo>>	"p4":[<<xy>>]		4th pointer location-change event; <<xy>> is the pointer location within current item	
<<eventInfo>>	"p4e":[<<xy>>]		4th pointer movement-end event; sent only when pointer stops moving for longer than 100ms (default) or whatever number of milliseconds is set via the "throt" <<interactProp>> for the "p4e" event	
<<eventInfo>>	"p4o":[1|0(,<<xy>>)?]		4th pointer moved over ("p4o":[1,<<xy>>]) or out of ("p4o":[0,<<xy>>]) current item; location where pointer left item is only sent if available	
<<eventInfo>>	"p4p":<<number>>		4th pointer pressure and hover distance; some pointer devices have pressure and/or hover sensitivity -- use the "pp" event to capture when pointer pressure or hover state changes; when pointer device is hovering -1 <= <<number>> < 0, where -1 is max hover detection range; when pointer device is touching 0 < <<number>> <= 1, where 1 is highest detectable pressure; "p4p":0 is sent when 4th pointer is no longer hovering or touching	
<<eventInfo>>	"g":[(<<padInfo>>(,<<padInfo>>)*)?]		gamepad state for primary gamepad (or some other button or pressure-button device)	
<<eventInfo>>	"g2":[(<<padInfo>>(,<<padInfo>>)*)?]		gamepad state for second gamepad (or some other button or pressure-button device)	
<<eventInfo>>	"g3":[(<<padInfo>>(,<<padInfo>>)*)?]		gamepad state for third gamepad (or some other button or pressure-button device)	
<<eventInfo>>	"g4":[(<<padInfo>>(,<<padInfo>>)*)?]		gamepad state for fourth gamepad (or some other button or pressure-button device)	
<<eventInfo>>	"play":0|1		media play/pause event listener; fires whenever user hits play/pause	
<<eventInfo>>	"at":<<number>>		media position event listener; fires whenever playback position changes	
<<eventInfo>>	"av":<<settings>>		audio/video settings; at a minimum <<settings>> should include "length":<<number>> to describe media duration in seconds; other potential <<settings>> that UI software may provide are "volume":<<uint>> (<<uint>> between 0 and 100), "rate":<<number>> (<<number>> signifies proportion of normal A/V speed, where 1 is normal speed), "quality":<<text>> (e.g., "quality":"hd1080"), and "captions":<<text>> (e.g., "captions":"English")	
<<padInfo>>	<<number>>		gamepad button/axis id and current state; the whole part of <<number>> represents button/axis identifier (zero-indexed), and the fractional part of the number its state; for buttons: when fractional part is zero, the button is up, and when it is non-zero, then the button is down (e.g., if first two gamepad controls are buttons, then UI->APP message {"t":<<ums>>,"g":[0.1,1]} means that first button was pressed and the second was released); for axes: the fractional part relays axis state, where .1 is lowest value, .5 is midpoint, and .9 is the highest possible value (e.g., gamepad controls 2 and 3 are horizontal and vertical axes of a thumbstick, then UI->APP message {"t":<<ums>>,"g":[2.1,3.5]} means that the thumbstick is pointing left); when gamepad is connected and "g" event is subscribed to, UI->APP message with initial gamepad state is sent (e.g., if gamepad has four buttons and two thumbsticks, when it's connected and APP->UI message {"on":{"g":[]}} is sent, the ensuing UI->APP message would be {"t":<<ums>>,"g":[0,1,2,3,4.5,5.5,6.5,7.5]})	
<<key>>	*** key values as specified by w3c; e.g., "ArrowLeft", " ", "q", "Q", "Escape"; see https://www.w3.org/TR/uievents-key/ for a list of legal key values ***			
<<keyCode>>	*** key codes as specified by w3c; e.g., "ArrowLeft", "Space", "KeyQ", "ControlLeft"; see https://www.w3.org/TR/uievents-code/ for a list of legal key codes ***			
<<prec>>	[]		capture all event values	
<<prec>>	<<values>>		precise value specification for discrete-value events (e.g., "v", "k", "md", "mu", "fold", "fcs", "po", "cut", "copy", "paste"); events are only captured/sent when event value is specified in <<values>>; for "md" and "mu" events, the <<values>> should be <<uint>>'s representing mouse buttons, not the <<xy>> mouse locations	Ex: APP->UI message {"on":{"k":["ArrowLeft","ArrowRight"]}} will initiate an event listener that will send UI->APP messages whenever left or right arrow keys are pressed
<<prec>>	[<<number>>]		precision specification for continuous-value events (e.g., "sx", "sy", "at", and "pp"); all event values are rounded to nearest <<number>> before sending; consecutive repeat event values for continuous events are not sent	
<<prec>>	[<<number>>]		precision specification for gamepad axes for events "g", "g2", "g3", "g4"; default precision for gamepad axes is 0.1; gamepad event values are rounded to nearest <<number>> before being sent; consecutive repeat gamepad event values are not sent	
<<prec>>	[<<xy>>]		precision specification for horizontal and vertical axes for all pointer and <<calcProp>> events (e.g., "p", "pd", "pu", "pc", "p2", "p3", "p4", "xy", "wh", "whc"); all locations are rounded to the nearest <<xy>> before being sent; consecutive repeat <<xy>> event values are not sent	Ex: APP->UI message {"on":{"p":[5,5]}} will add an event-listener that will fire every time that mouse location moves by 5 pixels on either axis
<<hashType>>	*** lowercase name of a hashing algorithm, no dashes; e.g. "md5", "sha256", "bcrypt"; use "!!require" directive to make sure UI software supports this hash type, e.g., {"!!require":{"hash":["sha512"]}} ***			
<<encryption>>	*** lowercase name of encryption algorithm, no dashes; e.g. "rsaoaep", "aes128ctr"; use "!!require" directive to make sure UI software supports this hash type, e.g., {"!!require":{"enc":["aes128ctr"]}} ***			
<<keyShortcut>>	"(meta )?(ctrl )?(alt )?(shift )?<<keyCode>>"		keyboard shortcut specification; if <<keyCode>> is not a modifier key, it may be preceded by ordered modifier key specification: "meta " (Windows logo or Apple Command key), "ctrl " (Control key), "alt " (Alt key), and/or "shift" (Shift key); e.g., <<keyShortcut>>'s "KeyA", "shift KeyA", "ctrl KeyA", and "ctrl shift KeyA" would activate when user presses keys A, shift+A, ctrl+A, and ctrl+shift+A, respectively	
<<format>>	*** a string containing a file type extension, or a hostname of embeddable media service; e.g., ".md" (markdown format), "youtube.com" (youtube video), ".mp3" (mp3 file) ***			
<<fileTypes>>	*** a string containing comma-separated list of one or more file type extensions; e.g., ".jpg,.jpeg,.png" ***			
<<plotType>>	"col"		this data series is displayed as a column chart; this plot-type is default; values for each data point in this series are column heights       	
<<plotType>>	"line"		this data series is displayed as a line chart; values for each data point in this series are y-values	
<<plotType>>	"xy"		this data series is displayed as a XY (scatter) chart; values for each data point in this series are y-values	
<<plotType>>	"box"		this data series is displayed as a box chart; value property "v" for each data point in this series is the mid-point of the box; "err" property is required to indicate height of the box; use "err":<<number>> to draw box edges equidistantly from mid-point, "err":[<<number>>,<<number>>] to indicate how far from the mid-point the top and bottom edges of the box are drawn, respectively, and [<<number>>,<<number>>,<<number>>,<<number>>] to draw box-and-whiskers	Ex: APP->UI message {"A":[{"c":"data","plt":"box","v":[100,102,101],"<-":{"err":[[5,5,10,10],[5,5,10,10],[5,5,10,10]]}}]} would add a box-and-whiskers plot with mid-points of the boxes being 100,102,101, height of each box extending above and below each mid-point by 5, and whiskers extending above and below each mid-point by 10
<<plotType>>	"ohlc"		this data series is displayed as an OHLC chart; value property "v" for each data point in this series is a y-value for closing price; use <<dpProp>> "af" to indicate the difference between opening and closing prices (open = v - af); "err" property for each data point in this series should be in the "err":[<<number>>,<<number>>] format, where <<number>>,<<number>> represent how far above the closing price the high was and how far below closing the low price was, respectively	Ex: {"c":"data","plt":"ohlc","v":[100,120,110,130],"<-":{"af":[5,18,-10,22],"err":[[10,10],[20,20],[15,15],[25,25]]}} will plot open-close values of 95-100, 102-120, 120-110, and 108-130, with high-low values for the data-points being 110-90, 140-100, 125-95, and 155-105
<<axisOpt>>	"caption":<<text>>	"cap":<<text>>	axis caption/title	
<<axisOpt>>	<<numProp>>		axis options for numeric marker values; if <<axisOpt>> "v" is not set, <<numOptions>> "min", "max", and "step" will be used to create axis markers; <<numProp>> "unit" may be used to format how marker values are displayed, or may be displayed as part of axis title	Ex: APP->UI message {"A":[{"c":"plot","id":"graph","axisx":{"min":0,"max":1,"step":0.2}}]} will add a plot "graph" to display with x-axis that includes markers [0.0,0.2,0.4,0.6,0.8,1.0]
<<axisOpt>>	"Class":"dt"	"c":"dt"	axis markers are of type datetime; if <<axisOpt>> "v" is not supplied, or if it includes numbers, those numeric values are treated as times	
<<axisOpt>>	"Class":"time"	"c":"time"	axis markers are of type time; if <<axisOpt>> "v" is not supplied, or if it includes numbers, those numeric values are treated as datetimes	
<<axisOpt>>	"value":[<<text>>(,<<text>>)*]	"v":[<<text>>(,<<text>>)*]	axis marker text legends; if this <<axisOpt>> is used, all <<numProp>> <<axisOpt>> are ignored; values are 1-indexed, and incremented by 1.0, such that the first <<text>> corresponds to 1.0 and the next <<text>> corresponds to 2.0 on this axis	Ex: APP->UI message {"A":[{"c":"plot","axisy":{"cap":"price","unit":"$"},"axisx":{"v":["item A","item B"]},"v":[[{"x":1,"h":20},{"x":2,"h":11}]]}]} will add a column chart to display with the first column indicating that item A costs $20, and second column indicating item B costs $11
<<shape>>	"b"		2d box (i.e., rectangle); use this shape with height of 1 (this is default height) to create a horizontal line or with a width of 1 (this is default width) to create a vertical line	
<<shape>>	"e"		2d ellipsoid (i.e., circle or stretched circle)	
<<shape>>	"s <<number>>( <<number>>)?"		2d slice (i.e., pie slice, circular sector); the 2 <<number>>'s define the arc size and starting angle of the slice, respectively -- where angle of 0 is left, the arc is drawn clockwise, and both numbers are specified in degrees; default value for starting angle is 0, thus <<shape>> "s 180" would be equivalent to <<shape>> "s 180 0", which is the top half of a circle; when the first <<number>> is >=360, this shape is a full ellipse (i.e., <<shape>> "s 360" is equivalent to <<shape>> "e"); the center of current item (i.e., specified via properties "x"/"y") is the center of the ellipsoid from which the arc is cut, the height (property "h") is the vertical diameter, and the width (property "w") is the horizontal diameter	Ex: APP->UI message {"A":[{"id":"pie","c":"2d","w":100,"h":100,"df":{"w":100,"h":100,"x":0,"y":0},"v":[{"id":"north","v":"s 90 45"]},{"id":"east","v":"s 90 135"},{"id":"south","v":"s 90 225"},{"id":"west","v":"s 90 315"}]}]} will add a 100x100 2d canvas called "pie" to display, with 4 slices inside it, pointing north, east, south, and west, respectively
<<shape>>	"t <<number>>"		2d triangle shape with a flat bottom stretching the width of this item, and a vertex at the top, where <<number>> indicates percentage of width that the vertex is offset from the left edge	Ex: <<shape>> "t 50" is a triangle with a flat bottom and a vertex at the top which is half-way between the left and right bottom vertices (and may be thought of as shorthand for <<shape>> "p 50 0 100 0 0 100 0 0"); Ex: <<shape>> "t 100" is a right triangle with a flat bottom and a perfectly vertical right edge (and may be thought of as shorthand for <<shape>> "p 100 0 100 0 0 100 0 0")
<<shape>>	"u <<number>>"		2d stadium shape (a.k.a., pill); <<number>> must be between 10 and 40, and specifies the percentage of height where the circular part of the stadium starts at the top and bottom of shape	
<<shape>>	"p <<side>> <<side>> <<side>> <<side>>"		2d custom polygon; the 4 <<side>>'s define sides along top, right, bottom, and left edges, respectively, with each <<side>> connecting to next <<side>> via a straight diagonal (see <<side>> description for more detail)	Ex: <<shape>> "p 25 50 50 0 25 50 50 0" is a hexagon with flat top/bottom; Ex: <<shape>> "p 50 0 100 0 0 100 0 0" is a pyramid-like triangle; Ex: <<shape>> "p 25 50 25 50 25 50 25 50" is an octagon
<<shape>>	"B"		3d box	
<<shape>>	"E"		3d ellipsoid (i.e., sphere or stretched sphere)	
<<shape>>	"S <<number>>( <<number>>)?"		3d slice of a cylinder (i.e., 3d pie slice, cylindrical sector); this cylindrical shape is always placed with the circular face facing the user (i.e., parallel to viewport) and the shaft of the cylinder stretching along the z-axis; the 2 <<number>>'s define the arc size and starting angle of the slice, respectively -- where angle of 0 is left, the arc is drawn clockwise, and both numbers are specified in degrees; default value for starting angle is 0, thus <<shape>> "S 180" would be equivalent to <<shape>> "S 180 0", which is the top half of a 3-dimensional pie slice; when the first <<number>> is >=360, this shape is a full cylinder	
<<shape>>	"T <<number>>"		3d triangular prism (i.e., wedge); this shape is a 3d version of <<shape>> "t <<number>>", and functions in the same way, except with depth	
<<shape>>	"U <<number>>"		3d capsule (a.k.a., pill); <<number>> must be between 10 and 40, and specifies the percentage of height where the spherical part of the capsule starts at the top and bottom of shape	
<<shape>>	"P <<side>> <<side>> <<side>> <<side>>"		3d custom prism; this shape is the same as the polygon ("p <<side>> <<side>> <<side>> <<side>>") <<shape>> in 2d, but with depth (i.e., for similarly specified polygon <<shape>> with 8 vertices in 2d, a corresponding 3d prism shape would have has 16 vertices, with 8 vertices in front making a 2d polygon, and 8 more being directly behind the first 8); the 4 <<side>>'s define sides along top, right, bottom, and left edges, respectively, with each <<side>> connecting to next <<side>> via a straight diagonal (see <<side>> description for more detail)	Ex: <<shape>> "m 25 50 50 0 25 50 50 0" is a hexagonal prism with flat top/bottom; Ex: <<shape>> "m 50 0 100 0 0 100 0 0" is a pyramid; Ex: <<shape>> "p 25 50 25 50 25 50 25 50" is an octagonal prism
<<2dProp>>	"x":<<number>>		horizontal position of item's center point relative to its parent's "x" coordinate (or relative to the top-left corner if the parent is a "2d" or "3d" viewport); default is 0	
<<2dProp>>	"y":<<number>>		vertical position of item's center point relative to its parent's "y" coordinate (or relative to the top-left corner if the parent is a "2d" or "3d" viewport); default is 0	
<<2dProp>>	"rotation":<<number>>	"rot":<<number>>	rotation of the item (in degrees, clockwise); rotation is always done around item center point, specified by "x"/"y" properties	
<<2dProp>>	"overlap":{(<<ovrOpt>>(,<<ovrOpt>>)*)?}	"ovr":{(<<ovrOpt>>(,<<ovrOpt>>)*)?}	overlap (collision) events options; use this option for detecting overlap between "gr" items or "grg" groups of items (does not detect overlap with "l" items); overlap is only checked for items that are currently moving due to animation; whichever rotation/scaling properties are implemented, those must be considered when calculating overlap (i.e., if a "gr" item is rotated and/or scaled, then overlap detection cannot be a simple bounding-box inclusion based on original "x"/"y"/"w"/"h" properties of the item, it has to be based on post-transform item size and location)	
<<3dProp>>	"z":<<number>>		position of item's center point on the z-axis relative to its parent's "z" coordinate, with larger values being farther from the user and lower values being closer to the user; default is 0	
<<3dProp>>	"rotationX":<<number>>	"rx":<<number>>	rotation around x-axis (pitch) in 3d context; rotation is always done around item center point, specified by "x"/"y"/"z" properties	
<<3dProp>>	"rotationY":<<number>>	"ry":<<number>>	rotation around y-axis (yaw) in 3d context; rotation is always done around item center point, specified by "x"/"y"/"z" properties	
<<ovrOpt>>	"of":<<overlapFunction>>		overlap function; specifies shape for calculating collisions (e.g., bounding box, radius, or rotated polygon based collisions); if this <<ovrOpt>> is not specified (i.e., <<overlapFunction>> is null), current item shape (i.e., "shp" <<grProp>>) is the <<overlapFunction>>; if neither this <<ovrOpt>> nor "shp" <<grProp>> are specified, <<overlapFunction>> defaults to "bb" (bounding box)	
<<ovrOpt>>	"brb":1		bounce/rollback option; if this option is enabled, this item is prevented from overlapping any item that also has <<ovrOpt>> "brb":1 by rolling back 1 animation frame whenever overlap is detected and stopping all 2d/3d animation of the two overlapping items (i.e., animation is stopped for <<propName>>'s x, y, z, w, h, d, x^, y^, z^, rot, rx, ry for both overlapping items); WARNING: only current item animation is stopped, not the parent "grg" item animations; the bounce/rollback event, "b", is triggered whenever two items with "brb":1 flag collide and at least one of the two is subscribed to the "b" event with the other, whereas overlap-start, "o", and overlap-end event, "e", can never be triggered between two items with "brb":1	Ex: APP->UI message {"A":[{"c":"2d","w":400,"h":300,"df":{"w":20,"h":20,"y":150,"ovr":{"b":[],"brb":1}},"v":[{"id":"A","±x":50},{"id":"B","x":350}]}]} will add a "2d" viewport to display with "gr" items A and B, A will be moving left to right at a speed of 50px/sec, and when item A collides with item B, animation will stop and either {"t":<<ums>>,"u":"A","b":"B"} or {"t":<<ums>>,"u":"B","b":"A"} UI->APP message will be sent
<<ovrOpt>>	"b":[(<<tag>>(,<<tag>>)*)?]		subscribe to bounce/rollback events; UI->APP message will be sent with "b" <<userProp>> whenever current item begins to overlap with any other item in current viewport that has one of the <<tag>>'s specified in its "tag" <<property>>; if no tags are specified (i.e., "b":[]), this event will trigger for all items in current viewport; when two items collide, only one UI->APP message is sent, not two	Ex: APP->UI message {"A":[{"c":"2d","w":400,"h":300,"df":{"w":20,"h":20,"y":150,"ovr":{"b":[],"brb":1}},"v":[{"id":"A","±x":50},{"id":"B","x":350}]}]} will add a "2d" viewport to display with "gr" items A and B, A will be moving left to right at a speed of 50px/sec, and when item A collides with item B, animation will stop and either {"t":<<ums>>,"u":"A","b":"B"} or {"t":<<ums>>,"u":"B","b":"A"} UI->APP message will be sent
<<ovrOpt>>	"o":[(<<tag>>(,<<tag>>)*)?]		subscribe to overlap-start events; UI->APP message will be sent with "o" <<userProp>> whenever current item begins to overlap with any other item in current viewport that has one of the <<tag>>'s specified in its "tag" <<property>>; if no tags are specified (i.e., "b":[]), this event will trigger for all items in current viewport; when two items collide, only one UI->APP message is sent, not two	Ex: APP->UI message {"A":[{"c":"2d","w":400,"h":300,"df":{"w":20,"h":20,"y":150,"ovr":{"o":[],"e":[]}},"v":[{"id":"A","±x":50},{"id":"B","x":350}]}]} will add a "2d" viewport to display with "gr" items A and B, A will be moving left to right at a speed of 50px/sec, and when item A begins to overlap with item B either {"t":<<ums>>,"u":"A","o":"B"} or {"t":<<ums>>,"u":"B","o":"A"} UI->APP message will be sent, and when this overlap ends and A passes B, either {"t":<<ums>>,"u":"A","e":"B"} or {"t":<<ums>>,"u":"B","e":"A"} UI->APP message will be sent
<<ovrOpt>>	"e":[(<<tag>>(,<<tag>>)*)?]		subscribe to overlap-end events; UI->APP message will be sent with "e" <<userProp>> whenever current item no longer overlaps with another item in current viewport that has one of the <<tag>>'s specified in its "tag" <<property>>; if no tags are specified (i.e., "b":[]), this event will trigger for all items in current viewport; when collision between two items ends, only one UI->APP message is sent, not two	Ex: APP->UI message {"A":[{"c":"2d","w":400,"h":300,"df":{"w":20,"h":20,"y":150,"ovr":{"o":[],"e":[]}},"v":[{"id":"A","±x":50},{"id":"B","x":350}]}]} will add a "2d" viewport to display with "gr" items A and B, A will be moving left to right at a speed of 50px/sec, and when item A begins to overlap with item B either {"t":<<ums>>,"u":"A","o":"B"} or {"t":<<ums>>,"u":"B","o":"A"} UI->APP message will be sent, and when this overlap ends and A passes B, either {"t":<<ums>>,"u":"A","e":"B"} or {"t":<<ums>>,"u":"B","e":"A"} UI->APP message will be sent
<<ovrOpt>>	"request":[<<req>>(,<<req>>)*]	"r":[<<req>>(,<<req>>)*]	info about current item to send to app alongside "o" or "e" or "b" <<userProp>> upon overlap/collision; the requested info will be sent back via <userProp>> "r":{<<reqInfo>>(,<<reqInfo>>)*}	
<<ovrOpt>>	"request2":[<<req>>(,<<req>>)*]	"r2":[<<req>>(,<<req>>)*]	info about the other item involved in collision to send to app alongside "o" or "e" or "b" <<userProp>> upon overlap/collision, if that item is static (i.e., not animating/moving); if "r2+" <<ovrOpt>> is not specified, info specified here is also sent for non-static collision targets; the requested info will be sent back via <userProp>> "r2":{<<reqInfo>>(,<<reqInfo>>)*}	
<<ovrOpt>>	"r2\+":[<<req>>(,<<req>>)*]		info about the other item involved in collision to send to app alongside "o" or "e" or "b" <<userProp>> upon overlap/collision, if that other item is not static (i.e., animating/moving); default value for this <<ovrOpt>> is whatever the value is for "r" <<ovrOpt>>; the requested info will be sent back via <userProp>> "r2":{<<reqInfo>>(,<<reqInfo>>)*}	
<<overlapFunction>>	<<shape>>		custom collision shape; e.g., an item whose shape is elliptical (i.e., "shp":"e") can still have <<overlapFunction>> "b" so that its overlap events are triggered based on rotated rectangle collision calculations	
<<overlapFunction>>	"bb"		2d bounding box (i.e., the smallest possible box that contains current shape, whose edges are all parallel to the viewport axes)	
<<overlapFunction>>	"r"		2d radius-based overlap, where radius is equivalent to the radius of a circle that would contain the entire bounding box of current item (i.e., r=sqrt(w^2+h^2)/2; e.g., for an unrotated rectangle with width of 3 and height of 4, the size of the max diagonal would be 5, and thus the radius would be 2.5)	
<<overlapFunction>>	"rw"		2d radius-based overlap, where radius is equivalent to half of item's width (or scaled width, if item is scaled)	
<<overlapFunction>>	"rh"		2d radius-based overlap, where radius is equivalent to half of item's height (or scaled height, if item is scaled)	
<<overlapFunction>>	"BB"		3d bounding box (i.e., the smallest possible box that contains current shape, whose edges are all parallel to the viewport axes)	
<<overlapFunction>>	"R"		3d radius-based overlap, where radius is equivalent to the radius of a sphere that would contain the entire bounding box of current item (i.e., r=sqrt(w^2+h^2+d^2)/2; e.g., for an unrotated box with width of 3 and height of 4 and depth of 5, the size of the diagonal would be sqrt(50), and thus the radius would be 3.536)	
<<overlapFunction>>	"RW"		3d radius-based overlap, where radius is equivalent to half of item's width (or scaled width, if item is scaled)	
<<overlapFunction>>	"RH"		3d radius-based overlap, where radius is equivalent to half of item's height (or scaled height, if item is scaled)	
<<overlapFunction>>	"RD"		3d radius-based overlap, where radius is equivalent to half of item's depth (or scaled depth, if item is scaled)	
<<animationVelocity>>	"±(frame)|(value)|(scrollX)|(scrollY)"	"+f|v|(sx)|(sy)"	animation velocity for generic item properties; <<property>> "value" can only be animated when it is <<number>> (i.e., <<itemClass>> is "num" or "dt" or "time")	
<<animationVelocity>>	"±x|y|(width)|(height)|(rotation)|(scaleX)|(scaleY)"	"+x|y|w|h|(rot)|(x^)|(y^)"	animation velocity for properties for items in 2d and 3d viewports	
<<animationVelocity>>	"±(depth)|z|(rotationX)|(rotationY)|(scaleZ)""	"+d|z|(rx)|(ry)|(z^)"	animation velocity for properties for items in 3d viewports	
<<animationOptions>>	"ª(frame)|(value)|(scrollX)|(scrollY)"	">f|v|(sx)|(sy)"	animation options; <<property>> "value" can only be animated when it is <<number>> (i.e., <<itemClass>> is "num" or "dt" or "time")	
<<animationOptions>>	"ªx|y|(width)|(height)|(rotation)|(scaleX)|(scaleY)"	">x|y|w|h|(rot)|(x^)|(y^)"	animation options for items in 2d and 3d viewports	
<<animationOptions>>	"ª(depth)|z|(rotationX)|(rotationY)|(scaleZ)"	">d|z|(rx)|(ry)|(z^)"	animation options for items in 3d viewports	
<<aniOpt>>	"\+\+":<<number>>		current acceleration (i.e., rate of change to current velocity per second)	
<<aniOpt>>	"step":<<number>>		animation step; if "step" is supplied, animation is not smooth, but rather jumps by <<number>>; "step" for <<propName>> "f" is always 1; if "step" is not supplied (null), and this is animation for <<propName>> "value" of a numeric item (component type "num" or "dt" or "time") then <<aniOpt>> "step" is inferred from this item's <<numProp>> "step"	Ex: APP->UI message {"A":[{"c":"time","id":"Time Left","v":30,"+v":-1,">v":{"min":0,"step":0.1}}]} will add a "time" item called "Time Left" to display, and animate its value from 00:30.000s down to 00:00.000s, reducing the item's value by 0.1 every 100 milliseconds, and will send a UI->APP message {"t":<<ums>>,"u":"Time Left","+v":"-1"} once animation stops (this is actually equivalent to {"A":[{"c":"time","id":"Time Left","v":30,"+v":-1,"min":0,"step":0.1}]})
<<aniOpt>>	"min":<<number>>		animation stopping point lower-bound; animation stops when animated property value is less than or equal to <<number>>; if "min" is not supplied (null) for "ªvalue", then <<aniOpt>> "min" is inferred from this item's <<numProp>> "min"; if "min" is not supplied (null) for "ªframe", "ªscrollX", or "ªscrollY", then <<aniOpt>> "min" is 0; when animation stops, the corresponding animated property <<propName>> is set to the <<number>>, and the corresponding <<animationVelocity>> "±<<propName>>" is set to "<<terminalVelocity>>" and a UI->APP message is sent with <<userProp>> "+<<propName>>":"<<terminalVelocity>>", where <<terminalVelocity>> is the terminal velocity -- the last known value of "±<<propName>>"	
<<aniOpt>>	"max":<<number>>		animation stopping point upper-bound; animation stops when animated property value is greater than or equal to <<number>>; if "max" is not supplied (null) for "ªvalue", then <<aniOpt>> "max" is inferred from this item's <<numProp>> "max"; if "max" is not supplied (null) for "ªscrollX", or "ªscrollY", then <<aniOpt>> "max" is 100; if "max" is not supplied (null) for "ªframe", then <<aniOpt>> "max" is equal to the maximum possible value for "frame" (i.e., length of <<animation>> property "frames" minus 1); when animation stops, the corresponding animated property <<propName>> is set to the <<number>>, and the corresponding <<animationVelocity>> "±<<propName>>" is set to "<<terminalVelocity>>" and a UI->APP message is sent with <<userProp>> "+<<propName>>":"<<terminalVelocity>>", where <<terminalVelocity>> is the terminal velocity -- the last known value of "±<<propName>>"	
<<aniOpt>>	"request":[<<req>>(,<<req>>)*]	"r":[<<req>>(,<<req>>)*]	info to send to app software (alongside <<userProp>> <<animationVelocity>>:"<<number>>") when animation reaches "min" or "max" value; the requested info will be sent back via <userProp>> "r":{<<reqInfo>>(,<<reqInfo>>)*}	
-	-	-	-	-
everything below is syntax/description for task instructions				
-	-	-	-	-
### Label Name	### Grammar	### ---	### Description	### Example
<<instructions>>	<<taskState>>:<<conds>>		instructions laying out task goals and end-state; replaces prior instructions for a given <<taskState>>	Ex: APP->UI message {"task":{"good":[{"v":"Correct"}],"bad":[{"v":"Incorrect"}],"win":[{"id":"Score","v":{"~":30}}],"end":[{"id":"Question","v":{">>":30}}]}} would instruct user to pursue a state where some item value is "Correct", avoid "Incorrect", that the task ends after Question 30, and that the primary goal is to get the value of Score as close to 30 as possible
<<instructions>>	"rules":[<<rule>>(,<<rule>>)*]		instructions laying out some if-then rules for the task; replaces prior rules	Ex: APP->UI message {"task":{"end":[{"id":"Round","v":{">>":10}}]},"rules":[{"if":{"id":"Timer","v":{">>":0}},"then":[{"U":"Round","v":{"+":1}}]}]} informs user that task will end after Round reaches 10, and that Round will increase by one after "Timer" reaches 0
<<taskState>>	"(good)|(bad)|(end)|(win)|(loss)"		task state; "good" signifies user should seek the described condition, "bad" signifies user is to avoid it, "end" signifies current condition describes when the task ends, and "win" or "loss" signify that the primary task objective is to pursue or to avoid current condition, respectively	Ex: APP->UI message {"task":{"good":[{"v":"Correct"}],"bad":[{"v":"Incorrect"}],"win":[{"id":"Score","v":{"~":30}}],"end":[{"id":"Question","v":{">>":30}}]}} would instruct user to pursue a state where some item value is "Correct", avoid "Incorrect", that the task ends after Question 30, and that the primary goal is to get the value of Score as close to 30 as possible
<<conds>>	[<<cond>>(,<<cond>>)*]		list of condition sets for current <<taskState>> or <<rule>>	
<<cond>>	{<<condProp>>(,<<condProp>>)*}		set of conditions; any of these may be met	Ex: {"task":{"good":[{"id":"Temp","v":{">":60,"<":80,"~":72}},{"id":"Humidity","v":{">":40,"<":65,"~":55}}]}} would instruct user there are two goals -- (1) to keep Temperature between 60 and 80, and the closer it is to 72, the better, and (2) to keep Humidity between 40 and 65, the closer to 55, the better
<<condProp>>	<<matchByVal>>|<<matchByOp>>		condition may match exact values or using inequality operators	
<<condProp>>	"task":<<taskState>>		task state condition	
<<condProp>>	"and":<<cond>>		additional condition that must be met for the current condition to be met	Ex: APP->UI message {"task":{"win":[{"task":"end","and":[{"id":"Player 1 Score","v":{">":{"uid":"Player 2 Score"}}}]}]}} would instruct user agent that the primary objective is to have a higher Player 1 Score than Player 2 Score when task ends
<<matchByOp>>	<<propName>>:{<<operator>>(,<<operator>>)*}		match by operator	Ex: APP->UI message {"task":{"end":[{"id":"Round","v":{">>":10}}],"win":[{"task":"end","and":[{"id":"Player 1 Score","v":{">":{"uid":"Player 2 Score"}}}]}]}} would instruct user that task ends after Round 10, and the primary objective is to have a higher Player 1 Score than Player 2 Score when task ends
<<operator>>	"=|(!=)|<|>|(<=)|(>=)":<<value>>|<<ref>>|<<valrefs>>		equality match operators; "=":<<valrefs>> is inclusion check (one of these <<valrefs>> must match); "!=":<<valrefs>> is a blacklist (no value can match)	Ex: {"task":{"good":[{"id":"Score","v":{">":[{"uid":"Player 2 Score"},{"uid":"Player 3 Score"},{"uid":"Player 4 Score"}]}}]}} would instruct user to seek Score that is higher than Player 2 Score, higher than Player 3 Score, and higher than Player 4 Score
<<operator>>	"~":<<value>>|<<ref>>		scalable match operator; the closer current item/property is to the specified <<value>>|<<ref>>, the more true the condition	Ex: {"task":{"good":[{"id":"Temperature","v":{">":60,"<":80,"~":72}}]}} would instruct user to keep Temperature between 60 and 80, the closer to 72, the better
<<operator>>	">>":<<value>>|<<ref>>		"after" match operator; the result is expected after <<value>>|<<ref>> has been reached; this is useful when indicating end of progression (regardless the direction of said progression)	Ex: {"task":{"end":[{"id":"Round","v":{">>":10}}]},"rules":[{"if":{"id":"Timer","v":{">>":0}},"then":[{"U":"Round","v":{"+":1}}]}]} informs user that task will end after Round reaches 10, and that Round will increase by one after "Timer" reaches 0
<<valrefs>>	[<<value>>|<<ref>>(,<<value>>|<<ref>>)*]			
<<ref>>	{<<refop>>(,<<refop>>)*}		value-by-reference; must include either "prop" or "uid" <<refop>>	
<<refop>>	"uid":<<uid>>		reference to another item (default is current item)	Ex: {"task":{"win":[{"id":"A","w":{">":{"uid":"B","*":0.75}}}]}} would instruct user that the primary objective is to get the width of item "A" to be higher than 75% of the width of item "B"
<<ref>>	"prop":<<propName>>		reference to a property value (default is current property)	Ex: {"task":{"good":[{"id":"A","w":{">":{"prop":"h"}}}]}} would instruct user to try and keep the width of item "A" to be greater than its height
<<refop>>	"\+|\*|^|(min)|(max)":<<number>>		numeric operation to perform on current value-by-reference prior to <<cond>> comparisons; numeric operations are performed in the following order: ^, *, +, min, max; "+":<<number>> adds <<number>> to referenced property value; "*":<<number>> multiplies referenced property value by <<number>>; "^":<<number>> raises referenced property value by <<number>> as exponent; "min":<<number>> uses <<number>> or referenced property value, whichever is smaller; "max":<<number>> uses <<number>> or referenced property value, whichever is greater; "*":<<number>> multiplies referenced property value by <<number>>	Ex: {"task":{"win":[{"id":"A","w":{">":{"uid":"B","*":0.75}}}]}} would instruct user that the primary objective is to get the width of item "A" to be higher than 75% of the width of item "B"
<<rule>>	{"if":<<conds>>,"then":[<<expected>>,(<<expected>>)*]}		if-then expectations for the task	Ex: APP->UI message {"task":{"end":[{"id":"Round","v":{">>":10}}]},"rules":[{"if":{"id":"Timer","v":{">>":0}},"then":[{"U":"Round","v":{"+":1}}]}]} informs user that task will end after Round reaches 10, and that Round will increase by one after "Timer" reaches 0
<<expected>>	{(<<expectedProp>>(,<<expectedProp>>)*}		expected updates	
<<expectedProp>>	"U":<<uid>>		unique id of item expected to be updated	
<<expectedProp>>	<<propName>>:<<value>>|<<container>>|<<ref>>		expected property change	
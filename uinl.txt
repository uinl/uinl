UINL (User Interface object-Notation Language)
v1.0.20201029



Sample Interaction
  Message Type        Message Content                                        Description
  *** app->ui ***     ["Hello World!",{"id":"click me","v":false}]           text "Hello World!" and button "click me" are added to user display
  *** ui->app ***     {"_":"click me","v":true,"u":3450}                     user clicks the button "click me" (3.45s after the UI loaded)
  *** app->ui ***     {"_":"click me","v":null}                              button "click me" is removed from the display
  *** app->ui ***     [{"id":"now click me","v":false}]                      button "now click me" is added to the display
  *** ui->app ***     {"_":"now click me","v":true,"u":17100}                user clicks the button "now click me" (17.1s after the UI loaded)
  *** app->ui ***     [null,"Goodbye."]                                      display is cleared, and then text "Goodbye." is added to the display

Spec
  Message Type        Grammar                                                Description
  *** app->ui ***     <<displayUpdate>>                                      application requests updates in user display
  *** ui->app ***     {<<userProp>>(,<<userProp>>)*}                         user-side action/event (e.g. button-click, textbox edit)

  Label Name          Grammar                                                Description
  <<displayUpdate>>   null                                                   clear & reset the display container and all its property settings; display container (root-level container) is a special container that cannot be removed, only reset
  <<displayUpdate>>   <<container>>                                          update display value via an array of item declarations
  <<displayUpdate>>   <<pList>>                                              update display properties and execute root-level commands
  <<container>>       [(<<item>>(,<<item>>)*)?]                              array of item declarations and commands for current container; new items are appended at the end of current container (e.g. app->ui message ["hello"] followed by app->ui message ["world"] will result in the display ["hello","world"])
  <<container>>       [null(,<<item>>)*]                                     delete all items in current container, then proceed with item declarations/updates
  <<item>>            <<value>>|<<container>>|<<pList>>                      an item may be declared by value/container or a list of properties (i.e., ["hello world"] is shorthand for [{"v":"hello world"}]); when item is declared by value, it has no id (or any other properties) (e.g., [{"v":1,"id":"x"},2] adds two numeric items to display, the first of which has an id "x", and the second with no id)
  <<pList>>           {<<property>>(,<<property>>)*}                         list of item properties
  <<property>>        "id":<<id>>                                            set item id; item <<id>> should be unique within its parent container (if not, updates intended for one item may end up updating its namesake sibling, and two buttons with the same <<id>> will send indistinguishable ui->app messages when clicked), and preferably unique within the entire display; app-side software is responsible for keeping child <<id>>'s unique within any given container; root-level container id is null; item <<id>> will be displayed as item title (see <<property>> "title" below for alternate behavior); Ex: [{"id":"x","v":"hello"},{"id":"y","v":"world"}] adds items "x":"hello" and "y":"world" to the display, and a follow-up message [{"id":"x","v":"goodbye"}] will remove the "x":"hello" item, and add "x":"goodbye" item to display
  <<property>>        "v":<<value>>|<<container>>                            set item value; setting "v" to null removes the item from display (e.g., {"_":0,"v":null} will remove the first item from the display); "v" is a special property whose value type always corresponds to UI component type (i.e., "v" numeric and text values indicate numeric and text UI components, boolean values indicate buttons, and an array indicates a container bin), and component type is *immutable* (i.e., cannot be changed after it is declared); any changes to "v" that are incompatible with its original type will be *ignored* (i.e., [{"id":"my text","v":"hello world"}] creates a text item, so a future update to it cannot be boolean or numeric or an array -- e.g. {"_":"my text","v":true}, {"_":"my text","v":true}, and {"_":"my text","v":[]} would all be ignored -- updates to this item value can only be text -- e.g. {"_":"my text","v":"goodbye"})
  <<property>>        <<Command>>                                            Commands alter how other properties are updated (but are not themselves lasting properties)
  <<property>>        <<uiDirective>>                                        root-level directives; these should only be specified at root-level of <<displayUpdate>> (e.g., {"require":...,"style":...})
  <<Command>>         "_":<<uid>>                                            find and update item with the specified <<uid>> (recursive search, starting at current container); "_" command can be specified as container property or as one of the updates inside the <<container>> array (i.e., both {"_":0,"v":null} and [{"_":0,"v":null}] will delete the first item in display); Ex: {"_":"my item","v":"hello world"} will find "my item" and change its value to "hello world"; Ex: {"_":["buttons",0],"v":null} will find a container named "buttons" and delete the first item in this container; Ex: {"_":"my container","v":[{"_":0,"v":"a"},{"_":1,"v":"b"},{"_":2,"v":"c"}]} will find "my container", and change its first, second, and third item values to "a", "b", and "c", respectively
  <<Command>>         "U":<<ums>>                                            UI-side timestamp for current declaration/update; used to delay the processing of the current update until user time has reached the marker specified <<ums>>; Ex: [{"v":"hello","U":2000},{"v":"world","U":1000}] will add the text "hello" to user display exactly 2.0s into the task, and add the text "world" 1.0s into the task, resulting in display ["world","hello"]; Ex: [{"id":"count","v":0},{"_":"count","U":10000,"v":1},{"_":"count","U":20000,"v":2}] will add an item "count" to display whose value is 0, then  change its value to 1 10.0s into the task, and then change its value to 2 20.0s into the task
  <<uiDirective>>     "require":{<<required>>(,<<required>>)*}               specify which options and option values are required for correctly interpreting essential application requests; if any of the <<required>> items are not implemented yet in the user software, the suggested behavior is to disconnect from the app after a polite {"u":<<ums>>,"!":"<<required>> is not implemented. Disconnecting."}
  <<uid>>             <<id>>|<<index>>|<<ids>>                               unique item <<id>>|<<index>> or unique set of item/order search to find an item on display
  <<id>>              <<text>>                                               unique item key; <<id>> of root container is null, and cannot be changed; <<id>> text is displayed as item title text (unless "title" optional property is specified, see below); Ex: [{"id":"Name","v":"Bob"},{"id":"Age","v":77}] adds two key:value pairs to the UI -- Name:Bob and Age:77
  <<index>>           <<uint>>                                               item index (i.e., order number within the current container); item numbering in a container begins at 0, thus {"_":0} is the first item in display
  <<ids>>             [<<id>>|<<index>>(,<<id>>|<<index>>)*]                 a sequence of id's to search; a search by <<ids>> is equivalent to multiple nested searches for <<id>>|<<index>> (i.e., {"_":["A","B","C"],...} = {"_":"A","v":[{"_":["B","C"],...}]} = {"_":"A","v":[{"_":"B","v":[{"_":"C",...}]}]}); Ex: "_":["id1","id2"] searches for container "id1", then, within that container searches for item "id2"
  <<value>>           <<text>>|<<number>>|<<boolean>>                        item value may be text, number, boolean (signifying a button)
  <<value>>           null                                                   setting item value to null will remove the corresponding item from container; Ex: {"_":0,"v":null} will remove the first item from the display
  <<ums>>             <<uint>>                                               time in milliseconds since the initiation of user software
  <<boolean>>         (true)|(false)                                         true or false boolean value
  <<text>>            *** see JSON string specification at json.org ***      text string
  <<number>>          *** see JSON number specification at json.org ***      numeric value; <<number>> must be higher than -9e99 and lower than 9e99
  <<number>>          9e99                                                   infinity
  <<number>>          -9e99                                                  -infinity
  <<number>>          ""                                                     NaN (i.e., not a number, no numeric value assigned)
  <<uint>>            ((1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)*)|0          positive integer, or zero
  <<userProp>>        "!":<<text>>                                           error message to be dumped into app-side error stream; Ex: ui->app message {"!":"there is a problem","u":<<ums>>} should write "there is a problem" into app-side error stream
  <<userProp>>        "u":<<ums>>                                            timestamp indicating when user input occurred; this <<userProp>> is present in every ui->app mesage; Ex: ui->app message {"_":"button 1","v":true,"u":7582} signifies that "button 1" was clicked by the user 7.582s from the time UI loaded
  <<userProp>>        "v":<<value>>                                          value indicating user-input; Ex: ui->app message {"_":"button 1","v":true,"u":<<ums>>} signifies that "button 1" was clicked by the user
  <<userProp>>        "_":<<id>>|<<index>>|<<idPath>>                        unique id or path for item being toggled/changed by user; this <<userProp>> is present in every ui->app message, except when id is null (i.e., when message does not apply to any specific item, but to the display as a whole, e.g. {"!":"some error","u":<<ums>>}); <<idPath>> should be used whenever <<id>>|<<index>> does not uniquely identify the item; <<id>> should be used instead of <<index>> whenever item has an <<id>>; Ex: ui->app message {"_":"button 1","v":true,"u":<<ums>>} signifies that "button 1" was clicked by the user; Ex: ui->app message {"_":["buttons",0],"v":true,"u":<<ums>>} signifies that the first button in the "buttons" container was clicked by the user
  <<idPath>>          [<<id>>|<<index>>(,<<id>>|<<index>>)*]                 hierarchical partial path to item; the last (right-most) <<id>>|<<index>> in <<idPath>> refers to the actual item where user-event has occurred, with each preceding <<id>>|<<index>> referring to item's parent, its parent's parent, etc.; when forming <<idPath>>, <<id>> should be used instead of <<index>> for any item that has an <<id>>; <<idPath>> only needs to include enough parent id's so as to provide a unique path to item (i.e., if any <<id>> in <<idPath>> is unique, its parents do not need to be included); Ex: ui->app message {"_":["buttons",0],"v":true,"u":<<ums>>} signifies that the first button in the "buttons" container was clicked by the user; Ex: ui->app message {"_":["my items",0,2],"v":true,"u":<<ums>>} means that the third item inside the first item of the "my items" container was toggled/clicked by the user

everything above is core-UINL (4 UI component classes, 5 properties/commands); all UI sw must be able to handle the format specified above for simple text+button tasks

==

everything below specifies optional UI sw features that enable more advanced UI interactions (14 additional UI component classes, 12 directives/commands, 49 standard (2D-static) UI properties/commands, 12 options for 2D animation, 17 options for 3D display and animation, and 32 named user-events)
if any of below UI features are required for essential app functionality, this should be specified via the "require" <<uiDirective>>; if application requires property values that user sw cannot handle, user software can disconnect; if some optional features are useful but not required, UI sw can simply ignore these (e.g. <<Command>> "U" may be useful for gathering user-agent and other user-side information, but should only be required if it is essential to task functionality)

  Label Name          Grammar                                                Description
  <<required>>        <<pName>>:<<values>>                                   specify properties/commands (and property values) necessary for this application; Ex: {"require":{"tag":[],"C":["table","popup"]}} says that UI sw must be able to handle "tag" and "C" directives, and specifically "table" and "popup" as potential property values for "C"; for any <<pName>> where its value can be an array or associative array (e.g. "R", "man"), {"require":{<<pName>>:<<values>>}} specifies which names are allowed in said array, (e.g. {"require":{"man":["w","h"]}} signifies that that some items' width and height properties must be interactive)
  <<pName>>           *** property name: the part to the left of the colon in the <<property>> expression (e.g. "v", "tag", "x") ***
  <<values>>          [(<<value>>(,<<value>>)*)?]

  <<property>>        <<pName>>:null                                         remove/reset property (i.e. clear or reset property to default behavior); this doesn't hold for immutable property "C", or for "v" ("v":null deletes the item)
  <<property>>        <<pName>>:{.*}                                         partially update property; only for properties whose values are mapped arrays -- "in", "on", "throt", "df", "axisx", "axisy"); Ex: {"on":{"kd":[]}} followed by {"on":{"ku":[]}} will add both keydown and keyup event-listeners to the display (rather than replacing the keydown with the keyup event-listener)

  <<uiDirective>>     "style":<<text>>                                       load preferred style template (for aesthetic appeal in human-centric UI); <<text>> is likely a set of CSS rules or a URL of a style-sheet, though it may contain or point to some other styling resource specific to a given UI software framework (e.g. javascript); "style" directive may be called multiple times to load multiple parts of a style template; task-side application can request userAgent information prior to supplying a style template (e.g., in the following sequence application sw finds out that UI sw is u1js and then supplies css to turn buttons green -- app->ui: {"R":["userAgent"]}, ui->app: {"u":<<ums>>,"userAgent":"u1js"}, app->ui: {"style":"[C='btn'] {background:green}"})
  <<uiDirective>>     "task":<<conds>>                                       task instructions; if task instruction specification is essential to the task, use "require":{..."task":[(<<condOptionName>>(,<<condOptionName>>)*)?]...} where <<condOptionName>> is a name of <<condOption>> or <<ref>> used in instructions (i.e., "#", "@", "state", "v", "=", "~", ">", "<", ">=", "<=", "!=", "&", "|", "+", "*", "^"); Ex: {"task":[{"state":"good","#":"Temperature",">":60,"<":80,"~":72}]} would instruct user to keep Temperature between 60 and 80, and the closer it is to 72, the better

  <<uiDirective>>     "\?":<<url>>                                           open external resource; Ex: {"?":"https://google.com"} will open google website in a separate window

  <<Command>>         "!":<<text>>                                           error or warning (or debugging) message to be dumped into UI error stream

  <<Command>>         "T":{(<<userProp>>(,(<<userProp>>)*)?}                 Triggered update; current update/declaration is triggered whenever ui->app message matches the specified <<userProp>>'s; use "T":{} as a wildcard to trigger whenever any ui->app message is sent; use "T" in combination with <<Command>> "Q" to make the response-trigger cancelable; delayed-update commands (U, T, S) are executed in reverse-alphabetical order; Ex: {"T":{"v":true},"in":-1} will disable all display interactions whenever a button is clicked (useful to prevent accidental repeat-clicks); Ex: {"T":{"_":"Submit","v":true},"v":[{"C":"popup","id":"Loading..."}]} will bring up a "Loading..." popup window when user clicks the "Submit" button
  <<Command>>         "S":<<number>>                                         Seconds to delay current update (i.e. timeout); <<number>> is the number of seconds to delay; delayed-update commands (U, T, S) are executed in reverse-alphabetical order; Ex: {"v":null,"S":2} will reset the screen after a 2 seconds timeout; Ex: [{"id":"text","v":"hello"},{"id":"text","v":null,"S":2}}] would add "text":"hello" to screen, and then remove it 2 seconds later

  <<Command>>         "R":[(<<req>>(,<<req>>)*)?]                            Request info; [(<<req>>(,<<req>>)*)?] describes the information to be sent back to application software; if <<req>> information is unavailable, the ui->app message must include <<req>>:null for the corresponding <<req>> (i.e., every requested <<req>> text must be included as a key in the corresponding ui->app message); requested info always gets aggregated and sent after the full update is complete (e.g., in the case where option T is used, info would get sent after animation is complete); Ex: app->ui message [{"id":"hello","v":"world","tag":["s1"],"U":2000,"R":["v","tag","foobar"]}] will cause "hello":"world" text item to be added to display 2.0s into the task, and immediately send ui->app message {"u":2000,"_":"hello","v":"world","tag":["s1"],"foobar":null}
  <<userProp>>        <<property>>|<<reqInfo>>                               information returned to application software, as requested via the "R" command; Ex: app->ui message {"R":["time"]} will trigger a ui->app response message indicating current date/time on user machine, e.g. {"u":<<ums>>,"time":"2020-04-27T11:26:43.967-04:00"}

  <<Command>>         "Q":<<qid>>                                            Queue identifier for current update; useful for resetting updates delayed via S, T, or U <<Command>>; updates delayed via S, T, or U commands that also include a <<qid>> are removed from queue next time an update is sent with the same <<qid>> reference; Ex: a app->ui message [{"id":"candles","v":0},{"_":"candles","v":1,"Q":"t1","U":10000},{"_":"candles","v":2,"Q":"t2","U":20000}] would add item "candles" with value 0 to display, and set up cancelable timers to change the value of "candles" to 1 at 10sec, then to 2 at 20sec into the task -- thus enabling a potential follow-up app->ui message {"Q":"t1"} to remove the update scheduled to occur at 10s, and/or {"Q":"t2"} to remove the update scheduled to occur at 20s (and {"Q":{}} to remove both scheduled updates)

  <<Command>>         "A":<<url>>                                            audio effect; plays audio file from specified <<url>>; if "Q":<<qid>> is specified alongside "A", this audioclip can be stopped with another reference to the same <<qid>> in a future app->ui message; to pre-load an audiofile and ensure UI software can play it, specify this file <<url>> among <<values>> for "A" in <<required>> specifications (e.g. {"require":{"A":["/sounds/coinfall.wav","http://sounds.com/exitmusic.mp3"]}}); Ex: {"A":"/sounds/hello.mp3"} will play /sounds/hello.mp3 file; Ex: [{"S":2,"v":"hello world","A":"ding.wav"}] will wait 2sec, add text "hello world" to screen, and play ding.wav sound effect upon this update; Ex: {"Q":"abc","A":"abc.mp3"} will play abc.mp3 -- however, if a follow-up app->ui message {"Q":"abc"} is sent while abc.mp3 is playing, the playback of abc.mp3 will be immediately stopped

  <<Command>>         "\*":{(<<searchTerm>>(,<<searchTerm>>)*)?}             update multiple existing display items; just like the "_" command, "*" command can be specified as container property or as one of the updates inside the <<container>> array (i.e., both {"_":"My Container","*":{},"tag":["critical"]} and {"_":"My Container","v":[{"*":{},"tag":["critical"]}]} will set all "tag" property of each item in My Container to "critical"); select all items that match all <<searchTerm>>'s in current container and update them according to current property specifications; if "*" is used in combination with "_" or "**", it is processed last, after either of those commands; if there are no <<searchTerm>>'s (i.e., "*":{}), all items are selected; Ex: {"*":{},"tag":["critical"]} sets text-color of all items in root to "critical"; Ex: {"_":"My numbers","*":{"C":"num"},"tag":["critical"]} sets text-color of all numeric items in "My numbers" container to "critical"
  <<Command>>         "\*\*":{(<<searchTerm>>(,<<searchTerm>>)*)?}           update multiple existing display items, recursively; just like the "_" command, "**" command can be specified as container property or as one of the updates inside the <<container>> array (i.e., both {"_":"My Container","**":{},"tag":["critical"]} and {"_":"My Container","v":[{"**":{},"tag":["critical"]}]} will set "tag" property of each item in My Container and its descendant containers to "critical"); select all items that match all <<searchTerm>>'s in current container and all its children, recursively, and update them according to current property specifications; if "**" is used in combination with "_" or "*", it is processed after "_" and before "*"; if there are no <<searchTerm>>'s (i.e., "**":{}), all items are selected; Ex: {"**":{},"tag":["critical"]} sets text-color of all items in display to "critical"; Ex: {"_":"My numbers","**":{"C":"num"},"tag":["critical"]} sets text-color of all numeric items in "My numbers" container or any of its descendant containers to "critical"

  <<Command>>         ">>":<<pList>>                                         set defaults for upcoming updates/declarations in current <<container>> array; apply current property specifications to all declarations/edits in the current container in the current app->ui message; i.e., app->ui message ["a","b",{">>":{"tag":["special"]}},"c","d","e"] is equivalent to app->ui message ["a","b",{"v":"c","tag":["special"]},{"v":"d","tag":["special"]},{"v":"e","tag":["special"]}]

  <<property>>        "C":<<itemClass>>                                      Class of UI component; default component class is "bin" (i.e., [{"id":<<id>>}] is equivalent to [{"id":<<id>>,"C":"bin"}]); this is an immutable property (i.e., "C" can only be set during initial item declaration, and an app->ui message like {"_":<<uid>>,"C":<<itemClass>>} is an illegal display update, as it attempts to change the component class of an existing item, and will be ignored); once component class is set, incompatible item values are ignored (e.g. component "select" is only compatible with boolean values, so if a "select" item was added to display -- [{"C":"select","id":"select me"}] -- a follow-up app->ui message {"_":"select me","v":"hello"} would be ignored)
  <<itemClass>>       "bin"                                                  container item; if "v" property isn't specified, it is set to []; this is a default <<container>> item -- [{"id":<<id>>,"C":"bin"}] is equivalent to [{"id":<<id>>,"v":[]}], which is also equivalent to [{"id":<<id>>}]
  <<itemClass>>       "txt"                                                  text item; if "v" property isn't specified, it is set to ""; this is a default <<text>> item -- [{"id":<<id>>,"C":"txt"}] is equivalent to [{"id":<<id>>,"v":""}]
  <<itemClass>>       "num"                                                  numeric item; if "v" property isn't specified, it is set to 0; this is a default <<number>> item -- [{"id":<<id>>,"C":"num"}] is equivalent to [{"id":<<id>>,"v":0}]
  <<itemClass>>       "btn"                                                  button item; if "v" property isn't specified, it is set to false; this is a default <<boolean>> item -- [{"id":<<id>>,"C":"btn"}] is equivalent to [{"id":<<id>>,"v":false}]
  <<itemClass>>       "hold"                                                 this item is a hold-down button -- a special <<boolean>> that sends <<userProp>> "v":true when pressed and "v":false when released
  <<itemClass>>       "select"                                               this item is a selectable option -- a special <<boolean>> that can be selected (setting <<property>> "v" to true) and deselected (setting <<property>> "v" to false) with alternating clicks
  <<itemClass>>       "private"                                              this item is text input that is masked for additional privacy -- its a special <<text>> item that is editable by default (default "in":1) and is masked (unreadable) when typed; Ex: [{"id":"Password","C":"private"}] would add a password field to the display
  <<itemClass>>       "html"                                                 this item is html body -- its a special <<text>> item that includes html tags; Ex: {"C":"html","v":"<b>this text is bold</b>"}; this should only be employed for displaying documents, not functional UI components, and with the assumption that many machine agents will ignore the tags inside html
  <<itemClass>>       "mkdn"                                                 this item is markdown text -- its a special <<text>> item that includes markdown syntax; Ex: {"C":"mk","v":"_this text is underlined_"}; this should only be employed for displaying formatted text, not functional UI components, and with the assumption that many machine agents will ignore the markdown syntax
  <<itemClass>>       "file"                                                 this item is a downloadable file blob -- a special <<text>> item that may be downloaded (and previewed, depending on UI software)
  <<itemClass>>       "popup"                                                this item is a popup -- a special <<container>> that pops up over other items of the parent container, partially obscuring their view and preventing them from being edited
  <<itemClass>>       "toast"                                                this item is a toast -- a special <<container>> that pops up temporarily and in a non-invasive way over parent container
  <<itemClass>>       "table"                                                this item is a table -- a special <<container>> that contains others <<container>> items, each of which will be a row in a table; Ex: [{"id":"personnel","v":[["name","age","gender"],["john",39,"m"],["mary",28,"f"]],"C":"table","head":1}] will add a "personnel" table with a header row and two records (john, mary)
  <<itemClass>>       "one"                                                  this item is a container with one child whose content is visible and other children whose content is hidden (usually represented as tabs, accordion, or a carousel) -- a special <<container>> where one child item always has a <<property>> "fold":1 and the rest of the children have <<property>> "fold":2; by default the first "one" child has <<property>> "fold":1 and the rest of the children have <<property>> "fold":2; setting any "one" child <<property>> "fold":1 will automatically set the rest of the children to "fold":2; user does not have the control to set "fold":2 for any "one" child (cannot hide a visible child), but can set "fold":1 (can show a given child, thus automatically hiding other children); Ex: app->ui message [{"C":"one","df":{"on":{"fold":[1]}},"v":[{"id":"A","v":"hello"},{"id":"B","v":"world"}]}] will add a container with two tabs to display, with item "A" being visible (displaying text "hello"), and if the user clicks on the second tab, item "B" will show (displaying text "world") and a ui->app message will be sent {"u":<<ums>>,"_":"B","fold":1}
  <<itemClass>>       "pie"                                                  this item is a pie -- a special <<container>> whose items are displayed as slices in a pie; items are added to "pie" container in a clockwise fashion, with the left bound of the first slice pointing up to 12 (use <<visOption>> "rot" to change pie orientation); the pie container is circular, where the minimum of its internal width/height is its diameter; each item in the pie (slice) will have default <<visOption>> "h" (i.e., its height or radius) equal to pie radius (i.e., half of pie diameter) -- the radius of a slice can be smaller than radius of the pie, but not greater; each slice will have default <<visOption>> "w" of 1, signifying that it takes up 1 part of the total pie; pie parts all have equal angles, and the more parts of the pie there are, the smaller of an angle each part is allotted; slices will not accept <<visOption>>'s other than "w" and "h"; Ex: app->ui message [{"C":"pie","rot":-45,"df":{"C":"btn"},"v":[{"id":"N"},{"id":"ESW","w":3}]}] will add a pie to the display with a button "N" pointing up, taking up 90deg of the pie, and a button "ESW" taking up the other 270deg of the pie
  <<itemClass>>       "l"                                                    this item is a line/link connecting other items -- a special <<container>> that contains <<uid>>'s of linked sibling/nephew items; by default, when <<property>> "v" is unspecified (i.e., "v":[] or "v":[null]), if <<property>> "tag" is specified -- this line connects all of its siblings that share any of its <<tag>>'s, and if <<property>> "tag" is unspecified -- this line connects all of its siblings; "l" item accepts no <<visOption>>'s; Ex: ["a","b","c","d",{"C":"l","v":[1,2],"dir":1,"title":"friendly"}] adds text items "a", "b", "c", and "d", with an arrow titled "friendly" going from "b" to "c"; Ex: [{"id":"some data","w":100,"h":100,"df":{"w":5,"h":5,"cc":3},"v":[{"x":10,"y":90},{"x":50,"y":50},{"x":90,"y":40},{"C":"l"}]}] adds a 100x100 container with a series of items and a line connecting them
  <<itemClass>>       "url"                                                  this item is a frame displaying external resources -- an item whose value is a <<url>>; <<interactOption>> "in":0 disables user interactions with the specified <<url>>; Ex: [{"C":"url","v":"/images/image1.jpg"},{"C":"url","v":"https://google.com"}] will add /images/image1.jpg image and a frame with google.com website to display
  <<itemClass>>       "media"                                                this item is embedded playable media (i.e., audio/video/slideshow) -- a special <<url>> item with playback capabilities; <<interactOption>> "in":0 disables user interactions with the specified media (i.e., app software may still start/end playback, but user-software cannot); Ex: [{"C":"media","v":"/video/v1.mp4","play":1,"in":0}] will add a non-interactive playing video to display 

  <<property>>        "i":<<index>>                                          index number for current item; if another item, X, with index number <<index>> exists in current current container, this item is inserted before X; if no item with <<index>> exists in current container, this item is moved to end of container; Ex: app->ui message ["a","b","c"] followed by [{"v":"x","i":1}] is equivalent to ["a","x","b","c"]
  <<property>>        "title":<<text>>                                       visible title (replaces item id as the visible title)
  <<property>>        "str":(-2)|(-1)|0|1|2                                  set item strength/importance (default is 0); for human users higher strength will make item more emphasized (e.g. thicker, brighter, vibrating) and lower strength will make item less emphasized (e.g. thinner, dimmer, smaller font)
  <<property>>        "tag":[<<tag>>(,<<tag>>)*]                             tag item for emphasis; each <<tag>> indicates the item is semantically [and thus visually] distinct from items that do not share this <<tag>>; if <<uint>> <<tag>>'s are implemented in human-facing UI software, they must be visually combinable; UI software for human users is not guaranteed to have distinct styles for a <<tag>> if it is <<text>> (rather than <<uint>>), thus visually-distinct styles for each text <<tag>> *must* be provided via the "style" <<uiDirective>>; additionally, if the text <<tag>>'s will be used in combinations, the supplied visual styles must be combinable
  <<property>>        "fold":0|1|2                                           item is foldable/minimizable; will not work for non-minimizable content (e.g. <<itemClass>> "btn" or "l"); "fold":0 (default) is the absence of any fold control, "fold":1 means that item is fully visible, but has a fold control (i.e. a button that minimizes the item), and "fold":2 means that item is folded (i.e. minimized) and has a control that would unfold it; avoid marking items foldable as an arbitrary style choice -- rather, mark an item as folded/foldable to signify this item's reduced prominence (as compared to items that are in full display)
  <<property>>        "tip":[<<text>>(,<<text>>)*]                           tooltip text to display when user needs more information about current item (e.g. for human users this is usually displayed when user hovers over the item)
  <<property>>        "ref":[<<uid>>(,<<uid>>)*]                             references to other items describing this item (e.g. footnotes, citations); Ex: [{"id":"Name","v":"","in":1,"ref":["Required"]},{"id":"Email","v":"","in":1,"ref":["Required"]},{"id":"Notes","v":"","in":1},{"id":"Required"}] adds text inputs Name, Email, and Notes to the display, as well as an item called Required, and references from Name and Email to Required (indicating to the user that those fields are required)
  <<property>>        <<interactOption>>                                     user-interaction options
  <<property>>        <<visOption>>                                          visual size/location/shape options; these options should be used *ONLY* when spacing/overlap information is requried for the application to function correctly, never just to make items distinct ("tag" <<property>> should be used for this purpose; e.g. if item shape is necessary to signify spacing, use "shp", but if it's just used to signify a semantic category, use "tag"), and never for aesthetic appeal ("style" <<uiDirective>> should be used for all specifications having to do with aesthetic appeal)
  <<property>>        <<containerOption>>                                    container options (also applicable to other item classes that can have child items, such as table and popup)
  <<property>>        <<boolOption>>                                         boolean item options
  <<property>>        <<numOption>>                                          number item options
  <<property>>        <<txtOption>>                                          text item options
  <<property>>        <<selectOption>>                                       select item options
  <<property>>        <<tableOption>>                                        table item options
  <<property>>        <<lnOption>>                                           line/link item options; these options should be used only when needed for the application to function correctly, never for aesthetic appeal ("style" <<uiDirective>> should be used for all specifications having to do with aesthetic appeal)
  <<property>>        <<fileOption>>                                         file, url, and media item options
  <<property>>        <<mediaOption>>                                        media item options
  <<property>>        <<animation>>                                          animation options

  <<interactOption>>  "in":0|1                                               interactive/input flag to signify whether user-input is disabled or enabled for non-container items; "in":0 (default for <<itemClass>> "txt", "num", "html", "mkdn") signifies input is disabled, "in":1 (default for <<itemClass>> "btn", "hold", "select", "private", "url", "media") signifies input is enabled; for all <<itemClass>>'s with the exception of "url" and "media", enabling user input means that the user can toggle item value (<<property>> "v"), and when user updates item value, UI software will send a ui->app message that would look as such: {"u":<<ums>>,"_":<<uid>>,"v":<<value>>}; <<itemClass>> "txt" must include a newline in the value to enable multi-line input (e.g. [{"id":"name","v":"","in":1},{"id":"story","v":"\n","in":1}] creates a single-line text input field called "name" and a multi-line one called "story"); Ex: [{"id":"type something","v":"","in":1},{"id":"button 1","v":false,"in":0}] will add a text input box titled "type something" and a disabled button "button 1" to display, sending ui->app message {"u":<<ums>>,"_":"type something","v":<<text>>} whenever user is done typing their input into the text input box
  <<interactOption>>  "in":-1                                                interactive transparency; this flag indicates that this item and its descendants accept zero interactions (all normally interactive controls, like scrolling and tooltips are turned off); all pointer interactions pass through this item (and its children); it may be warranted to combine this with <<property>> "opq":0, so as to enable visual transparency to go along with the interactive transparency
  <<interactOption>>  "man":[<<manOpt>>(,<<manOpt>>)*]                       enable manipulation of item positioning within its parent container; if <<manOpt>> null is enabled (deletion), if user deletes current item, ui->app message {"u":<<ums>>,"_":<<uid>>,"v":null} is sent; for any non-null <<manOpt>>, when user is done manipulating a given <<manOpt>>, ui->app message {"u":<<ums>>,"_":<<uid>>,<<manOpt>>:<<value>>} is sent; Ex: {"df":{"man":[null,"i","w"]}} tells the UI software that by default every item should have controls that enable its deletion, changing its index, and changing its width (and ui->app messages {"u":<<ums>>,"_":<<uid>>,"v":null}, {"u":<<ums>>,"_":<<uid>>,"i":<<uint>>}, and {"u":<<ums>>,"_":<<uid>>,"w":<<number>>} will be sent when user toggles these controls, respectively)
  <<interactOption>>  "on":{<<event>>:<<values>>(,<<event>>:<<values>>)*}    state-change event listeners; only triggered when <<event>> state-change is due to user action, user-software, or animation (i.e., not when the change is a part of <<displayUpdate>>); "on":{...<<event>>:[]...} tells user-side software to send <<eventInfo>> to application-side software whenever <<eventInfo>> state changes, whereas "on":{...<<event>>:<<values>>...} only sends <<eventInfo>> when <<eventInfo>> changes so as to include one of the <<values>> (e.g. {"_":"A","on":{"o":["B"]}} creates an overlap (i.e. collision) event-listener for item A that only triggers when A overlaps with item B); if <<value>> in <<values>> is numeric, user-side software is responsible for triggering event in case of imprecise movement through value (e.g. if event-listener "on":{"m":[10,20,30]} is added and mouse moves through the point 10,10, even if actual captured values jump from 9.3 to 11.7, <<eventInfo>> "m":[10,10] must be sent to app, when mouse passes through 20 on horizontal axis, <<eventInfo>> "m":[20,10] is sent to app, and then if it's moved down past 20 on vertical axis, <<eventInfo>> "m":[20,20] is sent to app); if multiple item events occur within the same frame of time, ui->app message includes all changed <<eventInfo>> in the same message; Ex: a <<displayUpdate>> {"on":{"w":[],"h":[]}} will add event-listeners for resize events to user display, and will send display width/height to application software every time root container changes size (e.g. because user resized the window or changed their display resolution) in the format {"u":<<ums>>,"w":<<number>>} or {"u":<<ums>>,"h":<<number>>} or {"u":<<ums>>,"w":<<number>>,"h":<<number>>}; Ex: a <<displayUpdate>> {"on":{"m":[],"sx":[],"sy":[],"k":["ArrowLeft","ArrowRight"]}} will add event-listeners for mouse, scroll, and keypress events to user display, and will send keypresses to application software whenever ArrowLeft/ArrowRight are pressed in the format {"u":<<ums>>,"k":"ArrowLeft"} {"u":<<ums>>,"k":"ArrowRight"}, or mouse coordinates to application software every time a mouse moves in the format {"u":<<ums>>,"m":[<<number>>,<<number>>]}, or scroll events in the formats {"u":<<ums>>,"sx":<<number>>} or {"u":<<ums>>,"sy":<<number>>} whenever the display root container scrolls horizontoally/vertically, or a combination of these if events occur within the same frame of time (e.g. {"u":<<ums>>,"m":[<<number>>,<<number>>],"sy":<<number>>})
  <<interactOption>>  "throt":{<<event>>:<<uint>>(,<<event>>:<<uint>>)*}     throttle event processing; specifies minimum timeout between same event triggers (in milliseconds); Ex: {"on":{"m":[]},"throt":{"m":50}} will send mouse coordinates no more often than every 50ms (i.e. max 20 messages per second)
  <<interactOption>>  "overlap":[(<<geometry>>)?(,<<geometry>>)*]            specifies geometric complexities required for "o" <<event>> intersection checking (e.g. z-index, rotation)
  <<interactOption>>  "hash":[<<hashType>>(,<<text>>)?]                      hash text input prior to sending (useful to add a layer of security); <<text>> is appended (i.e., added at the end) to item text before hashing (i.e., salt before hashing); Ex: [{"id":"Password","C":"private","hash":["sha256","salty"]}] would add a Password field to display, where the password is only ever sent to application software after being salted with "salty", and then hashed with sha256 hashing algorithm -- e.g., if user typed in "password" for password, the ui->app message would be {"_":"Password","v":"29d6afd14bbcdf0b43d1f2c4fd8ecbe8bdedd5ee255e5fa530a3fb968cbbfa1a","u":<<ums>>}
  <<interactOption>>  "focus":1|0                                            input focus; "focus":1 puts focus on current item (if possible) and removes focus from any other item; "focus":0 removes focus from current item
  <<interactOption>>  "keys":[<<key>>(,<<key>>)*]                            keyboard shortcuts assigned to an item; if this item is an interactive (not disabled) <<boolean>> (i.e., button, select), keyboard shortcut also toggles the item value (i.e., button is pressed, or item is selected) --- otherwise, if this item has a "fold" control, keyboard shortcut also toggles item fold state (folds or unfolds it) --- otherwise, if this item is interactive ("in":1), keyboard shortcut will toggle item focus ("focus" property changed to 1 if it's 0, or to 0 if it's 1)
  <<interactOption>>  "keymod":[<<modkey>>(,<<modkey>>)*]                    keyboard shortcut modifier keys (e.g. "Shift", "Alt", "Control"); each <<key>> specified for "keymod" must be pressed (in addition to one of the <<key>>'s specified for "keys") for keyboard shortcut to activate
  <<userProp>>        <<property>>|<<eventInfo>>                             property updates or events triggered by user input, user action, user software changes, or animation; Ex: if user input is enabled for container A width, [{"id":"A","in":{"w":1}}] will create a container A whose width can be changed by the user, and when user changes the width to 100, a ui->app message is sent {"w":100,"u":<<ums>>}

  <<visOption>>       "w":<<number>>                                         width of the item (based on parent resolution)
  <<visOption>>       "h":<<number>>                                         height of the item (based on parent resolution)
  <<visOption>>       "iw":<<number>>                                        internal visible width (resolution for internal horizontal coordinates for cw, sx, and all child items' x,w)
  <<visOption>>       "ih":<<number>>                                        internal visible height (resolution for internal vertical coordinates for ch, sy, and all child items' y,h)
  <<visOption>>       "cw":<<number>>                                        content width (i.e., scroll width); if "cw" property is unspecified, content width is automatically resized to fit all content; Ex: [{"w":200,"h":200,"iw":100,"ih":100,"cw":300,"ch":100}] adds a container to the display whose size is 200x200 in terms of display resolution, but its internal resolution is 100x100, it cannot be scrolled vertically because its content height is 100, but it can be scrolled horizontally because its content width is 300
  <<visOption>>       "ch":<<number>>                                        content height (i.e., scroll height); if "ch" property is unspecified, content height is automatically resized to fit all content; Ex: [{"w":200,"h":200,"iw":100,"ih":100,"cw":100,"ch":300}] adds a container to the display whose size is 200x200 in terms of display resolution, but its internal resolution is 100x100, it cannot be scrolled horizontally because its content width is 100, but it can be scrolled vertically because its content height is 300
  <<visOption>>       "sx":<<number>>                                        horizontal scrolling; if <<number>> is positive, "sx" indicates how far right to scroll -- i.e., how far left the content of this item is moved from right-most position; if <<number>> is negative, "sx" indicates how far left to scroll -- i.e., how far right the content of this item is moved from left-most position ("sx":-0 means item is scrolled all the way right -- yes, negative zeros are legal JSON -- if your UI software framework cannot add -0 values to JSON (i'm looking at you javascript) use approximations like "sx":-1e-9)
  <<visOption>>       "sy":<<number>>                                        vertical scrolling; if <<number>> is positive, "sy" indicates how far down to scroll -- i.e., how far up the content of this item is moved from bottom-most position; if <<number>> is negative, "sy" indicates how far up to scroll -- i.e., how far down the content of this item is moved from top-most position ("sy":-0 means item is scrolled all the way down -- yes, negative zeros are legal JSON -- if your UI software framework cannot add -0 values to JSON (i'm looking at you javascript) use approximations like "sy":-1e-9)
  <<visOption>>       "x":<<number>>                                         horizontal position of item; indicates how far to the right of parent container's left edge this item's left edge should be (see "bb" and "cc" <<visOption>>'s for alternate behavior)
  <<visOption>>       "y":<<number>>                                         vertical position of item; indicates how far down from parent container's top edge this item's top edge should be (see "bb" and "cc" <<visOption>>'s for alternate behavior)
  <<visOption>>       "bb":1|2|3                                             backwards/bottom-up positioning; "bb":1 means item's "x" property indicates the distance from its parents right edge to item's right edge, "bb":2 means item's "y" property indicates the distance from its parents bottom edge to item's bottom edge, and "bb":3 means both -- item's "x" and "y" properties indicate distances from its parents right/bottom edges to this item's right/bottom edges
  <<visOption>>       "cc":1|2|3                                             align to center; "cc":1 means item "x" property indicates position of item center (rather than left or right edge) on x-axis, "cc":2 means item "y" property indicates position of item center (rather than top or bottom edge) on y-axis, and "cc":3 means that both "x" and "y" properties are indicative of position of item center
  <<visOption>>       "z":<<uint>>                                           z-index (stack order) of the item; an item with greater stack order is always in front of an item with a lower stack order
  <<visOption>>       "rot":<<number>>                                       rotation of the item (in degrees)
  <<visOption>>       "shp":<<shape>>                                        set item geometric shape; Ex: [{"v":"this is a circle","shp":1,"w":100,"h":100}] creates a 100x100 circle with text "this is a circle" inside it
  <<visOption>>       "opq":1|0                                              set item as opaque or transparent; if this item overlaps with any of its siblings, "opq":0 ensures that this item is mostly transparent and any siblings behind it are mostly visible, and "opq":1 ensures this item is opaque and any siblings behind it are obstructed

  <<containerOption>> "df":<<pList>>                                         default property list for child elements; a child container inherits defaults from parent, but can overwrite some or all default properties with its own "df" specification; "df" <<pList>> cannot include "id"; if "df" <<pList>> includes "C", it is only applied to children whose "v" property isn't declared, or is compatible (e.g. class "select" is only compatible with boolean values, so {"df":{"C":"select"},"v":["hello","world",{"id":"a"},{"id":"b","v":false}]} will add two text items, "hello" and "world", and two selectable options "a" and "b"); if "df" <<pList>> includes "v", it is only applied to children whose "C" property isn't declared, or is compatible (e.g. class "select" is only compatible with boolean values, so {"df":{"v":true},"v":[{"id":"a","C":"select"},{"id":"b","C":"num"}]} will add a selectable option item "a" with a value of true, and a numeric item "b"); pList is updated by key rather than replaced when updated (to drop the entire df plist, set df to null); Ex: {"df":{"rnd":1}} will round all numeric fields to integers by default
  <<containerOption>> "axisx":{(<<axisOpt>>(,<<axisOpt>>)*)?}                x-axis label/markers
  <<containerOption>> "axisy":{(<<axisOpt>>(,<<axisOpt>>)*)?}                y-axis label/markers            
  <<containerOption>> <<3dOption>>                                           3d context options

  <<numOption>>       "min":<<number>>                                       minimum displayable value
  <<numOption>>       "max":<<number>>                                       maximum displayable value
  <<numOption>>       "rnd":<<number>>                                       round to the nearest <<number>>; if <<numOption>> "min" is present, rounding begins at "min" (e.g. ..."min":1,"rnd":2... is a set of all odd positive integers); Ex: [{"id":"x","v":57.1,"rnd":0.01}] should be interpreted/displayed as x=57.10, whereas [{"id":"x","v":57.1,"rnd":5}] should be interpreted/displayed as x=55, and [{"id":"x","v":57.1,"rnd":5,"min":-1}] should be interpreted/displayed as x=59
  <<numOption>>       "unit":<<datetime>>|<<text>>                           unit of measurement (e.g. "$", "%", "kg", " million", "$ k"); if "unit" is <<datetime>>, this numeric item will be treated as a date and/or time

  <<txtOption>>       "chmax":<<uint>>                                       max number of characters in <<text>>
  <<txtOption>>       "mark":[<<number>>,<<number>>]                         mark text region selection; <<number>>,<<number>> are start and end of region selection, respectively; each <<number>> must be an integer; when <<number>> is negative, characters are counted from end of string, where -1 is the end of text (i.e., "mark":[0,-1] selects entire text); UI sw is not guaranteed to prevent user from text-selection -- use "in":{"mark":0} to explicitly prevent user-side text selection

  <<selectOption>>    "group":<<text>>                                       if this property is present (not null), the "select" item belongs to a group (named via <<text>>) where only one item can be selected at a time (i.e. radio-buttons); Ex: [{"id":"Choose a car","df":{"C":"select","group":"car"},"v":[{"id":"Subaru"},{"id":"Tesla"}]}] creates a container "Choose a car" with two radio buttons -- "Subaru" and "Tesla" where only one can be chosen at a time

  <<tableOption>>     "head":0|1                                             if this value is 1, first row of a table is treated as the header row (default value is 0)
  <<tableOption>>     "dfcols":[<<pList>>(,<<pList>>)*]                      default options for all columns in the table; Ex: [{"C":"table","dfcols":[{},{"tag":0}]}] will add a table where the second column will include a <<tag>>, and thus will be visually distinct from other columns

  <<lnOption>>        "dir":(-1)|0|1                                         link direction; 0 (default) is a non-directional line/link, 1 signifies direction from earlier to later nodes, -1 signifies direction from later to earlier nodes

  <<fileOption>>      "ft":<<text>>                                          file type; some file types may be treated in special ways by UI software; if certain media filetype playback capability is required, app sw should check that UI sw can handle these via the "require" directive (e.g. {"require":{"ft":["mp3","youtube"]}} ensures mp3's and youtube videos can be embedded and controlled); Ex: [{"C":"url","v":"myimage.jpg","ft":"jpg","w":200,"h":150}] would announce that the url points to a jpg image (and most UI sw would display this image for human users as a 200x150 image); Ex: [{"C":"url","v":"myresults.csv","ft":"csv"}] would announce that the url points to a comma-separated data file (and some UI sw may provide special data visualization tools for previewing such formats)

  <<mediaOption>>     "play":1|0                                             audio/video time playback; "play":0 (default) indicates media is paused, "play":1 indicates it is playing
  <<mediaOption>>     "at":<<number>>                                        audio/video time position (in seconds)

  <<animation>>       "\+<<aniProp>>":{<<aniOpt>>(,<<aniOpt>>)*}             animation for numeric property; Ex: [{"id":"Time Left","v":30,"+v":{"to":0,"vy":-1},"rnd":1}] will add a numeric item called "Time Left" to display, and animate its value from 30 down to 0 at a rate of 1 per second

  Label Name          Grammar                                                Description
  <<conds>>           [<<cond>>(,<<cond>>)*]                                 add new task instructions
  <<conds>>           [null(,<<cond>>)*]                                     remove old instructions, and add new instructions in their stead
  <<cond>>            {<<condOption>>(,<<condOption>>)*}                     
  <<condOption>>      <<refop>>                                              item/property reference for current instructions rule
  <<condOption>>      "=|(!=)|<|>|(<=)|(>=)":<<value>>|<<ref>>|<<valrefs>>   match conditions; "=":<<valrefs>> is a whitelist (any value can match); "!=":<<valrefs>> is a blacklist (no value can match)
  <<condOption>>      "~":<<value>>|<<ref>>                                  scalable comparison; the closer current item/property is to the specified <<value>>|<<ref>>, the more true the condition; Ex: {"task":[{"state":"good","#":"Temperature",">":60,"<":80,"~":72}]} would instruct user to keep Temperature between 60 and 80, the closer to 72, the better
  <<condOption>>      "\|":<<conds>>                                         additional rule conditions that would qualify to match current rule condition; "|" is processed before "&"; Ex: {"task":[{"state":"bad","|":[{"#":"Temperature","<":60},{"#":"Temperature",">":80}]}]} would instruct user to avoid Temperature below 60 or above 80
  <<condOption>>      "&":<<conds>>                                          additional rules, given that the current condition is met; "&" is processed after "|"; Ex: {"task":[{"state":"end","#":"Round",">":10,"&":[{"state":"win","#":"Player 1 Score",">":{"#":"Player 2 Score"}}]}]} adds a rule indicating that after Round 10, the task is over, and the primary objective is to have a higher Player 1 Score than Player 2 Score at that time
  <<condOption>>      "state":"(good)|(bad)|(end)|(win)|(loss)"              task state; "good" signifies user should seek the described condition, "bad" signifies user is to avoid it, "end" signifies current condition describes when the task ends, and "win" or "loss" signify that the primary task objective is to pursue or to avoid current condition, respectively; Ex: {"task":[{"state":"good","@":"v","=":"Correct"},{"state":"bad","@":"v","=":"Incorrect"},{"state":"end","#":"Question",">":30},{"state":"win","#":"Score","~":{"@":"max"}}]} would instruct user to pursue a state where some item value is "Correct", avoid "Incorrect", that the task ends after Question 30, and that the primary goal is to get the value of Score as high as possible
  <<condOption>>      "v":<<displayUpdate>>                                  expectation of new display updates; Ex: {"task":[{"#":"Turn",">":3,"v":{"_":"Round","v":{"vy":1}}}]} adds a rule indicating that after Turn 3, Round will be incremented by 1; Ex: {"task":[{"|":[{"#":"Temperature","~":72},{"#":"Humidity","~":50}],"v":{"_":"Happy Human","v":100}}]} adds a rule indicating that as the Temperature gets closer to 72 and as Humidity gets closer to 50, the value of item "Happy Human" will get closer to 100
  <<valrefs>>         [<<value>>|<<ref>>(,<<value>>|<<ref>>)*]               
  <<ref>>             {<<refop>>(,<<refop>>)*}                               value-by-reference; must include either "@" or "#" <<refop>>
  <<refop>>           "@":<<pName>>                                          reference to a property value (default is "v")
  <<refop>>           "#":<<uid>>                                            reference to another item (default is current item)
  <<refop>>           "\+|\*|^|(min)|(max)":<<number>>                       numeric operation to perform on current value-by-reference prior to <<cond>> comparisons; numeric operations are performed in the following order: ^, *, +, min, max; "+":<<number>> adds <<number>> to referenced property value; "*":<<number>> multiplies referenced property value by <<number>>; "^":<<number>> raises referenced property value by <<number>> as exponent; "min":<<number>> uses <<number>> or referenced property value, whichever is smaller; "max":<<number>> uses <<number>> or referenced property value, whichever is greater; "*":<<number>> multiplies referenced property value by <<number>>; Ex: {"task":[{"state":"win","#":"A","@":"w",">":{"#":"B","@":"w","*":0.75}}]} would instruct user that the primary objective is to get the width of item "A" to be higher than 75% of the width of item "B"

  <<qid>>             <<number>>|<<text>>                                    queue identifier can be numeric or text
  <<qid>>             {}                                                     wildcard queue identifier; used to clear all promises, i.e., app->ui message {"Q":{}} stop/remove all rules, timeouts, and animations that included a <<qid>>

  <<req>>             <<pName>>                                              request property value for current item; Ex: ["a","b","c"] followed by {"_":1,"R":["v"]} would send back {"u":<<ums>>,"_":1,"v":"b"}
  <<req>>             *** name of info: the part to the left of the colon in the <<reqInfo>> expression (e.g. "ip", "url") ***
  <<reqInfo>>         "q":<<qid>>                                            current update's queue identifier; Ex: a app->ui message [{"id":"candles","v":0},{"_":"candles","v":1,"Q":"t1","S":10,"R":["q","v"]}] would add item "candles" with value 0 to display, and set up a timer with <<qid>> "t1" to change the value of "candles" to 1 after a 10sec delay -- after the update goes through, the requested info will be sent back via a ui->app message {"u":<<ums>>,"_":"candles","q":"t1","v":1}
  <<reqInfo>>         "tom":<<container>>                                    true object model; this is different from requesting property "v" of a container because true object model incorporates properties set via defaults, and never includes unimplemented options; Ex: app->ui message {"df":{"tag":0,"foo":"bar"},"v":[null,"a","b","c"],"R":["v","tom"]} will be responded to with a ui->app message {"u":<<ums>>,"v":[{"C":"txt","v":"a"},{"C":"txt","v":"b"},{"C":"txt","v":"c"}],"tom":[{"C":"txt","v":"a","tag":0},{"C":"txt","v":"b","tag":0},{"C":"txt","v":"c","tag":0}]}
  <<reqInfo>>         "ip":<<text>>                                          user-agent ip address
  <<reqInfo>>         "userAgent":<<text>>                                   information about UI software (e.g. type/version)
  <<reqInfo>>         "url":<<text>>                                         url (if any) employed by UI to connect to the app
  <<reqInfo>>         "time":<<text>>                                        full user local time, including milliseconds and timezone offset, in ISO8601 format (e.g. "2020-04-27T11:26:43.967-04:00")
  <<reqInfo>>         "screen":<<settings>>                                  user screen information (e.g. {"availWidth":1168,"availHeight":692,"width":1229,"height":692,"colorDepth":24,"pixelDepth":24,"availLeft":0,"availTop":0,"orientation":{"angle":0,"type":"landscape-primary"}}); at a minimum returned <<settings>> should include "width":<<number>> and "height":<<number>>
  <<settings>>        *** see JSON object specification at json.org ***      key-value pairs describing non-native UI component settings

  <<url>>             *** legal url ***

  <<searchTerm>>      <<pName>>:<<value>>                                    match property; Ex: {"**":{"v":1},"v":0} would set all 1's to 0's throughout the display; Ex: {"**":{"type":"bin","w":null},"w":100} will set widths of all containers that have no width to 100 throughout the display
  <<searchTerm>>      <<pName>>:<<values>>                                   match property array values or associative array keys; all specified <<value>>'s must be found in item property array or associative array for property to match; Ex: {"**":{"in":["w"]},"w":100} will find all items in display whose width sizes are interactive, and set each of their widths to 100

  <<value>>           {}                                                     wildcard non-null value; only for <<Command>>'s "*", "**", "T", and <<uiDirective>> "task" -- use {} instead of <<value>> to match any non-null value in <<searchTerm>>, <<userProp>>, or <<condOption>>; Ex: {"**":{"tag":{}},"tag":null} will annul all "tag" properties in the display

  <<tag>>             <<uint>>                                               predefined tags; to ensure that UI software for human users can automatically handle (will have distinct visual styles) for a given number of distinct <<uint>> <<tag>>'s, specify all required distinct tags in the <<required>> specification (e.g. {"require":{"tag":[0,1,2,3]}} ensures UI software can handle those 4 tags); if <<uint>> <<tag>>'s are implemented in human-facing UI software, they must be visually combinable
  <<tag>>             <<text>>                                               custom tags; for human users, if any <<tag>> is <<text>>, visually-distinct styles for each such <<tag>> *must* be provided via the "style" <<uiDirective>>

  <<manOpt>>          "i"                                                    enable manipulation of item index
  <<manOpt>>          null                                                   enable item deletion
  <<manOpt>>          "x"                                                    enable manipulation of item offset along horizontal axis
  <<manOpt>>          "y"                                                    enable manipulation of item offset along vertical axis
  <<manOpt>>          "w"                                                    enable manipulation of item width
  <<manOpt>>          "h"                                                    enable manipulation of item height
  <<manOpt>>          "rot"                                                  enable manipulation of item rotation
  <<manOpt>>          "dp"                                                   enable manipulation of item depth in 3d context
  <<manOpt>>          "z"                                                    enable manipulation of item offset along depth axis in 3d context
  <<manOpt>>          "rx"                                                   enable manipulation of item yaw (rotation around the vertical axis) in 3d context
  <<manOpt>>          "ry"                                                   enable manipulation of item pitch (rotation around the horizontal axis) in 3d context

  <<event>>           <<pName>>                                              event triggered when object property is changed by user action or user-side software or animation; Ex: app->ui message [{"id":"Search","v":"","in":1,"on":{"v":[]}}] will add a text input called "search" that sends ui->app messages {"u":<<ums>>,"_":"Search","v":<<text>>} every time the text in Search is changed by user (i.e., on every keystroke or cut/paste that changes <<text>>); Ex: app->ui message {"on":{"w":[],"h":[],"sx":[],"sy":[]}} will add event-listeners for scroll and resize events to user display, and will send resize/scroll events in the formats {"u":<<ums>>,"w":<<number>>} or {"u":<<ums>>,"h":<<number>>} or {"u":<<ums>>,"sx":<<number>>} or {"u":<<ums>>,"sy":<<number>>} whenever the display root container gets resized (e.g. due to window resize or resolution change on user-side) or when user scrolls horizontally/vertically, or a combination of these if events occur within the same frame of time (e.g. {"u":<<ums>>,"w":<<number>>,"h":<<number>>})
  <<event>>           *** name of event: the part to the left of the colon in the <<eventInfo>> expression (e.g. "o", "k", "m", "copy") ***
  <<eventInfo>>       "o":[<<uid>>(,<<uid>>)*]                               overlap (i.e. collision)
  <<eventInfo>>       "copy":<<text>>                                        text copied (in addition to standard clipboard copy, this should also capture when text is copied by dragging-dropping)
  <<eventInfo>>       "cut":<<text>>                                         text cut
  <<eventInfo>>       "paste":<<text>>                                       text pasted (in addition to standard clipboard paste, this should also capture when text is pasted by dragging-dropping)
  <<eventInfo>>       "k":<<key>>                                            keyboard key-press
  <<eventInfo>>       "kd":<<key>>                                           keyboard key-down
  <<eventInfo>>       "ku":<<key>>                                           keyboard key-up
  <<eventInfo>>       "m":[<<xy>>]                                           mouse coordinates
  <<eventInfo>>       "mb":[<<ums>>,<<xy>>(,<<ums>>,<<xy>>)*]                mouse timestamp/coordinate buffer
  <<eventInfo>>       "mo":1|0                                               mouse over/out
  <<eventInfo>>       "mc":[<<xy>>]                                          mouse click
  <<eventInfo>>       "mcc":[<<xy>>]                                         mouse double-click
  <<eventInfo>>       "md":[<<xy>>]                                          mouse button-down
  <<eventInfo>>       "mu":[<<xy>>]                                          mouse button-up
  <<eventInfo>>       "mc2":[<<xy>>]                                         mouse click for secondary mouse button
  <<eventInfo>>       "mcc2":[<<xy>>]                                        mouse double-click for secondary mouse button
  <<eventInfo>>       "md2":[<<xy>>]                                         mouse button-down for secondary mouse button
  <<eventInfo>>       "mu2":[<<xy>>]                                         mouse button-up for secondary mouse button
  <<eventInfo>>       "d":[<<xy>>,<<xy>>]                                    double pointer move
  <<eventInfo>>       "dd":[<<xy>>,<<xy>>]                                   double pointer-down
  <<eventInfo>>       "du":[<<xy>>,<<xy>>]                                   double pointer-up
  <<eventInfo>>       "e":[<<xy>>,<<xy>>,<<xy>>]                             three pointer move
  <<eventInfo>>       "ed":[<<xy>>,<<xy>>,<<xy>>]                            three pointer-down
  <<eventInfo>>       "eu":[<<xy>>,<<xy>>,<<xy>>]                            three pointer-up
  <<eventInfo>>       "f":[<<xy>>,<<xy>>,<<xy>>,<<xy>>]                      four pointer move
  <<eventInfo>>       "fd":[<<xy>>,<<xy>>,<<xy>>,<<xy>>]                     four pointer-down
  <<eventInfo>>       "fu":[<<xy>>,<<xy>>,<<xy>>,<<xy>>]                     four pointer-up
  <<eventInfo>>       "g":[(<<padInfo>>(,<<padInfo>>)*)?]                    gamepad state for primary gamepad
  <<eventInfo>>       "g2":[(<<padInfo>>(,<<padInfo>>)*)?]                   gamepad state for second gamepad
  <<eventInfo>>       "g3":[(<<padInfo>>(,<<padInfo>>)*)?]                   gamepad state for third gamepad
  <<eventInfo>>       "g4":[(<<padInfo>>(,<<padInfo>>)*)?]                   gamepad state for fourth gamepad
  <<eventInfo>>       "av":<<settings>>                                      audio/video settings; at a minimum <<settings>> should include "length":<<number>> to describe media duration in seconds; other potential <<settings>> that UI software may provide are "volume":<<uint>> (<<uint>> between 0 and 100), "rate":<<number>> (<<number>> signifies proportion of normal A/V speed, where 1 is normal speed), "quality":<<text>> (e.g., "quality":"hd1080"), and "captions":<<text>> (e.g., "captions":"English")
  <<xy>>              <<number>>,<<number>>                                  location within item content
  <<padInfo>>         <<number>>                                             gamepad button/axis id and current state; for button N [N is an integer identifier, 0<N<100], <<padInfo>> = (N) if button is down and <<padInfo>> = (-N) if button is up; for axis N [N is an integer identifier, 0<N<100] in position X [X is an integer signifying how far axis is from its lowest position, 0<=X<100, for middle position on axis is X=49], <<padInfo>> = (N*100 + X); Ex: <<displayUpdate>> {"on":{"g":[]}} would listen for all primary gamepad events, and if a gamepad with 4 buttons and 2 thumbsticks is connected, ui->app message will be {"u":<<ums>>,"g":[-1,-2,-3,-4,149,249,349,449]}, signifying that there are 4 buttons (none are pressed) and 4 axes (one horizontal and one vertical for each thumbstick); Ex: (continuing prior example) if second button is pressed, ui->app message will be {"u":<<ums>>,"g":[2]}, signifying that the state of the gamepad has changed in that button 2 is down, and once the button is released, ui->app message will be {"u":<<ums>>,"g":[-2]}

  <<geometry>>        "z|(shp)|(rot)|(C)"                                    geometry complication taken into account when calculating overlap
  <<geometry>>        "(dp)|(rx)|(ry)"                                       geometry complications in 3d context; taken into account when calculating overlap in 3d context

  <<hashType>>        *** lowercase name of a hashing algorithm, no dashes; e.g. "md5", "sha1", "sha2"; use "require" directive to make sure UI sw supports this hash type, e.g., {"require":{"hash":["sha512"]}} ***

  <<shape>>           0|1                                                    predefined geometric shape; 0 is a box shape, 1 is a round shape (i.e. ellipsoid)
  <<shape>>           [<<side>>,<<side>>,<<side>>,<<side>>]                  custom geometric shape; the 4 <<side>>'s define polygon points along top, right, bottom, and left edges of the current container's edges; to ensure UI software can handle custom shapes, specify [] among <<values>> in <<required>> specification (e.g. {"require":{"shp":[0,1,[]]}}); Ex: "shp":[25,50,50,0,25,50,50,0] is a hexagon with flat top/bottom; Ex: "shp":[50,0,100,0,0,100,0,0] is a pyramid; Ex: "shp":[50,0,"o",100,0,100,0,0,0,"o"] is a hat
  <<side>>            <<uint>>,<<uint>>(,"o|c")?                             each <<side>> contains two <<uint>>'s that describe the start and length of the line along a given edge as percentages of shift from prior edge -- e.g., for top edge of the shape (first <<side>>), <<side>> 25,40 signifies a horizontal line along top edge, starting 25% from left edge and ending 65% from left edge, and for left edge (fourth <<side>>) <<side>> 25,70 signifies a vertical line along left edge, starting 25% from bottom edge and ending 95% from bottom edge; optionally, each <<side>> ends with either "o" to signify that the line drawn to next edge's first point should be curved outward (bezier point is the intersection of current and next edge, i.e. top-right, bottom-right, bottom-left, top-left for the for <<side>>'s, respectively), or "c" to signify it should be curved inwardly (bezier point is center of shape); Ex: "shp":[25,50,50,0,25,50,50,0] is a hexagon with flat top/bottom; Ex: "shp":[50,0,100,0,0,100,0,0] is a pyramid; Ex: "shp":[50,0,"o",100,0,100,0,0,0,"o"] is a hat

  <<datetime>>        ":(<<timeField>>)+"                                    indicate that this numeric item represents date/time; Ex: [{"v":1483968000,"unit":":YMDhm"}] adds the date/time 2017/01/09 1:20pm to the display; Ex: [{"v":543.21,"unit":":ms."}] adds 9:03.210 (9min, 3sec, 210ms) to the display
  <<timeField>>       Y|M|D|d|h|m|s|.                                        the characters "YMDdhms." correspond to Year, Month, Day, day of week, hours, min, sec, and milliseconds

  <<axisOpt>>         "title":<<text>>                                       axis title
  <<axisOpt>>         <<numOption>>                                          axis options for numeric marker values; <<numOption>>'s "rnd" and "unit" are used to format how marker values are displayed; if <<axisOpt>> "v" is not set, <<numOptions>> "min", "max", and "rnd" will be used to automatically add axis values; if neither "v" nor "min"/"max" are set, axis markers will correspond to container's internal size; Ex: [{"id":"graph","w":100,"h":100,"axisx":{"min":0,"max":1,"rnd":0.2}}] will add a container "graph" to display with x-axis that includes markers [0.0,0.2,0.4,0.6,0.8,1.0]
  <<axisOpt>>         "v":[<<number>>(,<<number>>)*]                         axis marker numeric values; if neither "v" nor "min"/"max"/"rnd" are set, axis markers will correspond to container's coordinates; Ex: [{"id":"graph","w":100,"h":100,"axisy":{"v":[0,1,10,100,1000,10000]}}] will add a container "graph" to display with a log-scale y-axis, going from 0 to 10,000 from bottom to top of container
  <<axisOpt>>         "v":[<<text>>(,<<text>>)*]                             axis marker text legends; if neither "v" nor "min"/"max"/"rnd" are set, axis markers will correspond to container's coordinates; Ex: [{"id":"cols","w":100,"h":100,"axisx":{"v":["group A","group B"]}}] will add a container "cols" to display with two labels on x-axis - "group A" and "group B"
  <<axisOpt>>         "x":[<<number>>(,<<number>>)*]                         horizontal coordinates for x-axis markers; if "x" is not set for axisx, markers are evenly-spaced from left-most to right-most point of item content (see <<axisOpt>> "bb" for alternate behavior); Ex: [{"id":"cols","w":100,"iw":4,"h":100,"axisx":{"v":["group A","group B"],"x":[1,2]}}] will add a container "cols" to display with with internal width of 4.0 and two labels on x-axis - "group A" and "group B" at horizontal coordinates 1.0 and 2.0, respectively
  <<axisOpt>>         "y":[<<number>>(,<<number>>)*]                         vertical coordinates for y-axis markers; if "y" is not set for axisy, markers are evenly-spaced from bottom to top-most point of item content (see <<axisOpt>> "bb" for alternate behavior); Ex: [{"id":"bars","w":100,"ih":4,"h":100,"axisy":{"v":["group A","group B"],"y":[2,1]}}] will add a container "cols" to display with with internal height of 4.0 and two labels on y-axis - "group A" and "group B" at horizontal coordinates 2.0 and 1.0, respectively ("group A" is below "group B")
  <<axisOpt>>         "z":[<<number>>(,<<number>>)*]                         offset coordinates for z-axis markers in 3d context; if "y" is not set for axisy, markers are evenly-spaced from bottom to top-most point of item content; Ex: [{"id":"bars","w":100,"ih":4,"h":100,"axisy":{"v":["group A","group B"],"y":[2,1]}}] will add a container "cols" to display with with internal height of 4.0 and two labels on y-axis - "group A" and "group B" at horizontal coordinates 2.0 and 1.0, respectively ("group A" is below "group B")
  <<axisOpt>>         "bb":0|1                                               axis markers offsets are backwards/bottom-up; for x-axis, "bb":0 (default) means markers are placed left-to-right and "bb":1 means they go right-to-left, and for y-axis, "bb":1 (default) means markers are placed bottom-to-top and "bb":0 means they go top-to-bottom; for z-axis in 3d context, "bb":0 (default) means markers are placed front-to-back and "bb":1 means they go back-to-front

  <<3dOption>>        "dp":<<number>>                                        depth of the item; indicates this container has a 3d context (z-axis in addition to x/y axes); for containers only; if this property is specified for any item, container gets a 3D context, and for human users (depending on ui software) may drastically change its visual representation
  <<3dOption>>        "idp":<<number>>                                       internal depth of the item in 3d context
  <<3dOption>>        "cdp":<<number>>                                       content depth of the item in 3d context
  <<3dOption>>        "bb":4|5|6|7                                           behind-to-front positioning in 3d context; "bb":4 means that in 3d context item "z" property indicates distance from the far-edge of parent container to far-edge of current item (rather than from the front edge of parent to the front edge of current), "bb":5 does the combination of "bb":4 and "bb":1, "bb":6 does the combination of "bb":4 and "bb":2, and "bb":7 does the combination of "bb":4 and "bb":3
  <<3dOption>>        "cc":4|5|6|7                                           align to center in 3d context; "cc":4 means that in 3d context item "z" property indicates position of item center (rather than front or back edge) on z-axis, "cc":5 centers item on both x and z axes, "cc":6 centers it on y and z axes, and "cc":7 means item is centered on all three axes
  <<3dOption>>        "z":<<number>>                                         position of item on z-axis in 3d context; only for items inside a container with depth; indicates how far from the front edge of parent container the front edge of this container should be (see "bb" and "cc" <<3dOption>>'s for alternate behavior)
  <<3dOption>>        "sz":<<number>>                                        depth scrolling in 3d context; only for containers with depth
  <<3dOption>>        "rx":<<number>>                                        rotation around y-axis (yaw) in 3d context; only for containers with depth
  <<3dOption>>        "ry":<<number>>                                        rotation around x-axis (pitch) in 3d context; only for containers with depth
  <<3dOption>>        "axisz":{(<<axisOpt>>(,<<axisOpt>>)*)?}                z-axis label/markers in 3d context

  <<key>>             *** key values as specified by w3c; e.g., "ArrowLeft", " ", "q", "Q", "Escape"; see https://www.w3.org/TR/uievents-key/ for a list of legal key values ***
  <<modkey>>          *** modifier key values as specified by w3c; e.g., "Shift", "Alt", "Control"; see https://www.w3.org/TR/uievents-key/ for a list of legal key values ***

  <<aniProp>>         v|x|y|w|h|(sx)|(sy)|(rot)|(iw)|(ih)|(cw)|(ch)          animatable properties; <<property>> "v" can only be animated when it is <<number>> (i.e., <<itemClass>> is "num")
  <<aniProp>>         (dp)|z|(sz)|(rx)|(ry)|(idp)|(cdp)                      animatable properties in 3d context
  <<aniOpt>>          "vy":<<number>>                                        current velocity (rate of change per second); Ex: [{"id":"Time Left","v":30,"+v":{"to":0,"vy":-1},"rnd":1}] will add a numeric item called "Time Left" to display, and animate its value from 30 down to 0 at a rate of 1 per second
  <<aniOpt>>          "to":<<number>>                                        animate numeric property toward <<number>>; "to" <<aniOpt>> is necessary to begin animation; Ex: [{"id":"Time Left","v":30,"+v":{"to":0,"vy":-1},"rnd":1}] will add a numeric item called "Time Left" to display, and animate its value from 30 down to 0 at a rate of 1 per second
  <<aniOpt>>          "to":<<numbers>>                                       sequence of animations; "to" <<aniOpt>> is necessary to begin animation; animate numeric property toward each <<number>> in a sequence of <<numbers>>; barring any <<aniOpt>>'s that indicate to the contrary, rate of change for animated property will remain the same between each target <<number>>, though the direction (+/-) will change automatically so that property value is moving toward specified target; Ex: [{"id":"A","x":0,"+x":{"to":[100,0],"vy":20}}] adds an item called "A" to display, and animates its "x" property (its location on x-axis) from 0 to 100, and then back to 0, at a rate of 20 per second
  <<aniOpt>>          "ti":<<uint>>                                          index of current target; useful for changing animation mid-stream, or checking animation status via "R" <<Command>>
  <<aniOpt>>          "tu":<<uint>>                                          target sequence rerUn (i.e., repeat; e.g., <<pName>>:{"to":[100,200],"tu":2,"vy":<<number>>} is equivalent to <<pName>>:{"to":[100,200,100,200,100,200],"vy":<<number>>}); Ex: [{"id":"A","x":0,"+x":{"to":[100,0],"vy":20,"tu":9e99}}] adds an item called "A" to display, and animates its "x" property (its location on x-axis) from 0 to 100, and then back to 0, at a rate of 20 per second, and repeats this forever
  <<aniOpt>>          "te":<<number>>                                        target Exit velocity as a proportion of terminal velocity; 
  <<aniOpt>>          "te":<<numbers>>                                       target Exit velocities for respective targets; 
  <<aniOpt>>          "ta":<<number>>|<<numbers>>                            target attraction factor(s); signifies acceleration toward target(s); if target attraction is negative (i.e. repelling force) and current velocity is in the direction of target, animation will decelerate, and will stop (and move onto next target) when velocity reaches zero; Ex: app->ui message [{"w":15,"h":15,"shp":1,"+x":{"to":[184,0],"vy":80,"ta":-10},"+y":{"to":84,"ta":100,"te":-0.5,"tu":10}}] will add a 15x15 circle to the display and then animate its position as if there was gravity and atmospheric friction, dropping down at an acceleration of 100 pixels/sec/sec, then bouncing up (at y:84) and falling back down again (10 times), while also moving right while decelerating at 10 pixels/sec/sec, and bouncing off (at x:184) to move back left
  <<numbers>>         [<<number>>(,<<number>>)*]                             list of numeric values

